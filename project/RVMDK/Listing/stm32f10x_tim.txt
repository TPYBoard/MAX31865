; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\output\stm32f10x_tim.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\output\stm32f10x_tim.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\User -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\bsp_lib -IE:\keli\ARM\RV31\INC -IE:\keli\ARM\CMSIS\Include -IE:\keli\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\stm32f10x_tim.crf ..\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_tim.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  TIM_DeInit PROC
;;;121      */
;;;122    void TIM_DeInit(TIM_TypeDef* TIMx)
000000  b510              PUSH     {r4,lr}
;;;123    {
000002  4604              MOV      r4,r0
;;;124      /* Check the parameters */
;;;125      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;126     
;;;127      if (TIMx == TIM1)
000004  48fe              LDR      r0,|L1.1024|
000006  4284              CMP      r4,r0
000008  d108              BNE      |L1.28|
;;;128      {
;;;129        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  14c0              ASRS     r0,r0,#19
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;130        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
000012  2100              MOVS     r1,#0
000014  14e0              ASRS     r0,r4,#19
000016  f7fffffe          BL       RCC_APB2PeriphResetCmd
00001a  e0c4              B        |L1.422|
                  |L1.28|
;;;131      }     
;;;132      else if (TIMx == TIM2)
00001c  f1b44f80          CMP      r4,#0x40000000
000020  d108              BNE      |L1.52|
;;;133      {
;;;134        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
000022  2101              MOVS     r1,#1
000024  4608              MOV      r0,r1
000026  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;135        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
00002a  2100              MOVS     r1,#0
00002c  2001              MOVS     r0,#1
00002e  f7fffffe          BL       RCC_APB1PeriphResetCmd
000032  e0b8              B        |L1.422|
                  |L1.52|
;;;136      }
;;;137      else if (TIMx == TIM3)
000034  48f3              LDR      r0,|L1.1028|
000036  4284              CMP      r4,r0
000038  d108              BNE      |L1.76|
;;;138      {
;;;139        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
00003a  2101              MOVS     r1,#1
00003c  2002              MOVS     r0,#2
00003e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;140        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
000042  2100              MOVS     r1,#0
000044  2002              MOVS     r0,#2
000046  f7fffffe          BL       RCC_APB1PeriphResetCmd
00004a  e0ac              B        |L1.422|
                  |L1.76|
;;;141      }
;;;142      else if (TIMx == TIM4)
00004c  48ee              LDR      r0,|L1.1032|
00004e  4284              CMP      r4,r0
000050  d108              BNE      |L1.100|
;;;143      {
;;;144        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
000052  2101              MOVS     r1,#1
000054  2004              MOVS     r0,#4
000056  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;145        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
00005a  2100              MOVS     r1,#0
00005c  2004              MOVS     r0,#4
00005e  f7fffffe          BL       RCC_APB1PeriphResetCmd
000062  e0a0              B        |L1.422|
                  |L1.100|
;;;146      } 
;;;147      else if (TIMx == TIM5)
000064  48e9              LDR      r0,|L1.1036|
000066  4284              CMP      r4,r0
000068  d108              BNE      |L1.124|
;;;148      {
;;;149        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
00006a  2101              MOVS     r1,#1
00006c  2008              MOVS     r0,#8
00006e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;150        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
000072  2100              MOVS     r1,#0
000074  2008              MOVS     r0,#8
000076  f7fffffe          BL       RCC_APB1PeriphResetCmd
00007a  e094              B        |L1.422|
                  |L1.124|
;;;151      } 
;;;152      else if (TIMx == TIM6)
00007c  48e4              LDR      r0,|L1.1040|
00007e  4284              CMP      r4,r0
000080  d108              BNE      |L1.148|
;;;153      {
;;;154        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
000082  2101              MOVS     r1,#1
000084  2010              MOVS     r0,#0x10
000086  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;155        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
00008a  2100              MOVS     r1,#0
00008c  2010              MOVS     r0,#0x10
00008e  f7fffffe          BL       RCC_APB1PeriphResetCmd
000092  e088              B        |L1.422|
                  |L1.148|
;;;156      } 
;;;157      else if (TIMx == TIM7)
000094  48df              LDR      r0,|L1.1044|
000096  4284              CMP      r4,r0
000098  d108              BNE      |L1.172|
;;;158      {
;;;159        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
00009a  2101              MOVS     r1,#1
00009c  2020              MOVS     r0,#0x20
00009e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;160        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
0000a2  2100              MOVS     r1,#0
0000a4  2020              MOVS     r0,#0x20
0000a6  f7fffffe          BL       RCC_APB1PeriphResetCmd
0000aa  e07c              B        |L1.422|
                  |L1.172|
;;;161      } 
;;;162      else if (TIMx == TIM8)
0000ac  48da              LDR      r0,|L1.1048|
0000ae  4284              CMP      r4,r0
0000b0  d108              BNE      |L1.196|
;;;163      {
;;;164        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
0000b2  2101              MOVS     r1,#1
0000b4  1440              ASRS     r0,r0,#17
0000b6  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;165        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);
0000ba  2100              MOVS     r1,#0
0000bc  1460              ASRS     r0,r4,#17
0000be  f7fffffe          BL       RCC_APB2PeriphResetCmd
0000c2  e070              B        |L1.422|
                  |L1.196|
;;;166      }
;;;167      else if (TIMx == TIM9)
0000c4  48d5              LDR      r0,|L1.1052|
0000c6  4284              CMP      r4,r0
0000c8  d109              BNE      |L1.222|
;;;168      {      
;;;169        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);
0000ca  2101              MOVS     r1,#1
0000cc  04c8              LSLS     r0,r1,#19
0000ce  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;170        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);  
0000d2  2100              MOVS     r1,#0
0000d4  f44f2000          MOV      r0,#0x80000
0000d8  f7fffffe          BL       RCC_APB2PeriphResetCmd
0000dc  e063              B        |L1.422|
                  |L1.222|
;;;171       }  
;;;172      else if (TIMx == TIM10)
0000de  48d0              LDR      r0,|L1.1056|
0000e0  4284              CMP      r4,r0
0000e2  d109              BNE      |L1.248|
;;;173      {      
;;;174        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);
0000e4  2101              MOVS     r1,#1
0000e6  0508              LSLS     r0,r1,#20
0000e8  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;175        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);  
0000ec  2100              MOVS     r1,#0
0000ee  f44f1080          MOV      r0,#0x100000
0000f2  f7fffffe          BL       RCC_APB2PeriphResetCmd
0000f6  e056              B        |L1.422|
                  |L1.248|
;;;176      }  
;;;177      else if (TIMx == TIM11) 
0000f8  48ca              LDR      r0,|L1.1060|
0000fa  4284              CMP      r4,r0
0000fc  d109              BNE      |L1.274|
;;;178      {     
;;;179        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);
0000fe  2101              MOVS     r1,#1
000100  0548              LSLS     r0,r1,#21
000102  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;180        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);  
000106  2100              MOVS     r1,#0
000108  f44f1000          MOV      r0,#0x200000
00010c  f7fffffe          BL       RCC_APB2PeriphResetCmd
000110  e049              B        |L1.422|
                  |L1.274|
;;;181      }  
;;;182      else if (TIMx == TIM12)
000112  48c5              LDR      r0,|L1.1064|
000114  4284              CMP      r4,r0
000116  d108              BNE      |L1.298|
;;;183      {      
;;;184        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, ENABLE);
000118  2101              MOVS     r1,#1
00011a  2040              MOVS     r0,#0x40
00011c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;185        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);  
000120  2100              MOVS     r1,#0
000122  2040              MOVS     r0,#0x40
000124  f7fffffe          BL       RCC_APB1PeriphResetCmd
000128  e03d              B        |L1.422|
                  |L1.298|
;;;186      }  
;;;187      else if (TIMx == TIM13) 
00012a  48c0              LDR      r0,|L1.1068|
00012c  4284              CMP      r4,r0
00012e  d108              BNE      |L1.322|
;;;188      {       
;;;189        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, ENABLE);
000130  2101              MOVS     r1,#1
000132  2080              MOVS     r0,#0x80
000134  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;190        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, DISABLE);  
000138  2100              MOVS     r1,#0
00013a  2080              MOVS     r0,#0x80
00013c  f7fffffe          BL       RCC_APB1PeriphResetCmd
000140  e031              B        |L1.422|
                  |L1.322|
;;;191      }
;;;192      else if (TIMx == TIM14) 
000142  48bb              LDR      r0,|L1.1072|
000144  4284              CMP      r4,r0
000146  d108              BNE      |L1.346|
;;;193      {       
;;;194        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
000148  2101              MOVS     r1,#1
00014a  1580              ASRS     r0,r0,#22
00014c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;195        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE);  
000150  2100              MOVS     r1,#0
000152  15a0              ASRS     r0,r4,#22
000154  f7fffffe          BL       RCC_APB1PeriphResetCmd
000158  e025              B        |L1.422|
                  |L1.346|
;;;196      }        
;;;197      else if (TIMx == TIM15)
00015a  48b6              LDR      r0,|L1.1076|
00015c  4284              CMP      r4,r0
00015e  d109              BNE      |L1.372|
;;;198      {
;;;199        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, ENABLE);
000160  2101              MOVS     r1,#1
000162  0408              LSLS     r0,r1,#16
000164  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;200        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, DISABLE);
000168  2100              MOVS     r1,#0
00016a  f44f3080          MOV      r0,#0x10000
00016e  f7fffffe          BL       RCC_APB2PeriphResetCmd
000172  e018              B        |L1.422|
                  |L1.372|
;;;201      } 
;;;202      else if (TIMx == TIM16)
000174  48b0              LDR      r0,|L1.1080|
000176  4284              CMP      r4,r0
000178  d109              BNE      |L1.398|
;;;203      {
;;;204        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, ENABLE);
00017a  2101              MOVS     r1,#1
00017c  0448              LSLS     r0,r1,#17
00017e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;205        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, DISABLE);
000182  2100              MOVS     r1,#0
000184  f44f3000          MOV      r0,#0x20000
000188  f7fffffe          BL       RCC_APB2PeriphResetCmd
00018c  e00b              B        |L1.422|
                  |L1.398|
;;;206      } 
;;;207      else
;;;208      {
;;;209        if (TIMx == TIM17)
00018e  48ab              LDR      r0,|L1.1084|
000190  4284              CMP      r4,r0
000192  d108              BNE      |L1.422|
;;;210        {
;;;211          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, ENABLE);
000194  2101              MOVS     r1,#1
000196  0488              LSLS     r0,r1,#18
000198  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;212          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, DISABLE);
00019c  2100              MOVS     r1,#0
00019e  f44f2080          MOV      r0,#0x40000
0001a2  f7fffffe          BL       RCC_APB2PeriphResetCmd
                  |L1.422|
;;;213        }  
;;;214      }
;;;215    }
0001a6  bd10              POP      {r4,pc}
;;;216    
                          ENDP

                  TIM_TimeBaseInit PROC
;;;225      */
;;;226    void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
0001a8  2200              MOVS     r2,#0
;;;227    {
;;;228      uint16_t tmpcr1 = 0;
;;;229    
;;;230      /* Check the parameters */
;;;231      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;232      assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
;;;233      assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
;;;234    
;;;235      tmpcr1 = TIMx->CR1;  
0001aa  8802              LDRH     r2,[r0,#0]
;;;236    
;;;237      if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)||
0001ac  4b94              LDR      r3,|L1.1024|
0001ae  4298              CMP      r0,r3
0001b0  d00e              BEQ      |L1.464|
0001b2  4b99              LDR      r3,|L1.1048|
0001b4  4298              CMP      r0,r3
0001b6  d00b              BEQ      |L1.464|
0001b8  f1b04f80          CMP      r0,#0x40000000
0001bc  d008              BEQ      |L1.464|
0001be  4b91              LDR      r3,|L1.1028|
0001c0  4298              CMP      r0,r3
0001c2  d005              BEQ      |L1.464|
;;;238         (TIMx == TIM4) || (TIMx == TIM5)) 
0001c4  4b90              LDR      r3,|L1.1032|
0001c6  4298              CMP      r0,r3
0001c8  d002              BEQ      |L1.464|
0001ca  4b90              LDR      r3,|L1.1036|
0001cc  4298              CMP      r0,r3
0001ce  d104              BNE      |L1.474|
                  |L1.464|
;;;239      {
;;;240        /* Select the Counter Mode */
;;;241        tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
0001d0  f64f738f          MOV      r3,#0xff8f
0001d4  401a              ANDS     r2,r2,r3
;;;242        tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
0001d6  884b              LDRH     r3,[r1,#2]
0001d8  431a              ORRS     r2,r2,r3
                  |L1.474|
;;;243      }
;;;244     
;;;245      if((TIMx != TIM6) && (TIMx != TIM7))
0001da  4b8d              LDR      r3,|L1.1040|
0001dc  4298              CMP      r0,r3
0001de  d007              BEQ      |L1.496|
0001e0  4b8c              LDR      r3,|L1.1044|
0001e2  4298              CMP      r0,r3
0001e4  d004              BEQ      |L1.496|
;;;246      {
;;;247        /* Set the clock division */
;;;248        tmpcr1 &= (uint16_t)(~((uint16_t)TIM_CR1_CKD));
0001e6  f64f43ff          MOV      r3,#0xfcff
0001ea  401a              ANDS     r2,r2,r3
;;;249        tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
0001ec  88cb              LDRH     r3,[r1,#6]
0001ee  431a              ORRS     r2,r2,r3
                  |L1.496|
;;;250      }
;;;251    
;;;252      TIMx->CR1 = tmpcr1;
0001f0  8002              STRH     r2,[r0,#0]
;;;253    
;;;254      /* Set the Autoreload value */
;;;255      TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
0001f2  888b              LDRH     r3,[r1,#4]
0001f4  8583              STRH     r3,[r0,#0x2c]
;;;256     
;;;257      /* Set the Prescaler value */
;;;258      TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
0001f6  880b              LDRH     r3,[r1,#0]
0001f8  8503              STRH     r3,[r0,#0x28]
;;;259        
;;;260      if ((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM15)|| (TIMx == TIM16) || (TIMx == TIM17))  
0001fa  4b81              LDR      r3,|L1.1024|
0001fc  4298              CMP      r0,r3
0001fe  d00b              BEQ      |L1.536|
000200  4b85              LDR      r3,|L1.1048|
000202  4298              CMP      r0,r3
000204  d008              BEQ      |L1.536|
000206  4b8b              LDR      r3,|L1.1076|
000208  4298              CMP      r0,r3
00020a  d005              BEQ      |L1.536|
00020c  4b8a              LDR      r3,|L1.1080|
00020e  4298              CMP      r0,r3
000210  d002              BEQ      |L1.536|
000212  4b8a              LDR      r3,|L1.1084|
000214  4298              CMP      r0,r3
000216  d101              BNE      |L1.540|
                  |L1.536|
;;;261      {
;;;262        /* Set the Repetition Counter value */
;;;263        TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
000218  7a0b              LDRB     r3,[r1,#8]
00021a  8603              STRH     r3,[r0,#0x30]
                  |L1.540|
;;;264      }
;;;265    
;;;266      /* Generate an update event to reload the Prescaler and the Repetition counter
;;;267         values immediately */
;;;268      TIMx->EGR = TIM_PSCReloadMode_Immediate;           
00021c  2301              MOVS     r3,#1
00021e  8283              STRH     r3,[r0,#0x14]
;;;269    }
000220  4770              BX       lr
;;;270    
                          ENDP

                  TIM_OC1Init PROC
;;;278      */
;;;279    void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000222  b570              PUSH     {r4-r6,lr}
;;;280    {
;;;281      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000224  2400              MOVS     r4,#0
000226  2200              MOVS     r2,#0
000228  2300              MOVS     r3,#0
;;;282       
;;;283      /* Check the parameters */
;;;284      assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;285      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;286      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;287      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;288     /* Disable the Channel 1: Reset the CC1E Bit */
;;;289      TIMx->CCER &= (uint16_t)(~(uint16_t)TIM_CCER_CC1E);
00022a  8c05              LDRH     r5,[r0,#0x20]
00022c  f64f76fe          MOV      r6,#0xfffe
000230  4035              ANDS     r5,r5,r6
000232  8405              STRH     r5,[r0,#0x20]
;;;290      /* Get the TIMx CCER register value */
;;;291      tmpccer = TIMx->CCER;
000234  8c02              LDRH     r2,[r0,#0x20]
;;;292      /* Get the TIMx CR2 register value */
;;;293      tmpcr2 =  TIMx->CR2;
000236  8883              LDRH     r3,[r0,#4]
;;;294      
;;;295      /* Get the TIMx CCMR1 register value */
;;;296      tmpccmrx = TIMx->CCMR1;
000238  8b04              LDRH     r4,[r0,#0x18]
;;;297        
;;;298      /* Reset the Output Compare Mode Bits */
;;;299      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC1M));
00023a  f64f758f          MOV      r5,#0xff8f
00023e  402c              ANDS     r4,r4,r5
;;;300      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC1S));
000240  1eb5              SUBS     r5,r6,#2
000242  402c              ANDS     r4,r4,r5
;;;301    
;;;302      /* Select the Output Compare Mode */
;;;303      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
000244  880d              LDRH     r5,[r1,#0]
000246  432c              ORRS     r4,r4,r5
;;;304      
;;;305      /* Reset the Output Polarity level */
;;;306      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1P));
000248  1e75              SUBS     r5,r6,#1
00024a  402a              ANDS     r2,r2,r5
;;;307      /* Set the Output Compare Polarity */
;;;308      tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
00024c  890d              LDRH     r5,[r1,#8]
00024e  432a              ORRS     r2,r2,r5
;;;309      
;;;310      /* Set the Output State */
;;;311      tmpccer |= TIM_OCInitStruct->TIM_OutputState;
000250  884d              LDRH     r5,[r1,#2]
000252  432a              ORRS     r2,r2,r5
;;;312        
;;;313      if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM15)||
000254  4d6a              LDR      r5,|L1.1024|
000256  42a8              CMP      r0,r5
000258  d00b              BEQ      |L1.626|
00025a  4d6f              LDR      r5,|L1.1048|
00025c  42a8              CMP      r0,r5
00025e  d008              BEQ      |L1.626|
000260  4d74              LDR      r5,|L1.1076|
000262  42a8              CMP      r0,r5
000264  d005              BEQ      |L1.626|
;;;314         (TIMx == TIM16)|| (TIMx == TIM17))
000266  4d74              LDR      r5,|L1.1080|
000268  42a8              CMP      r0,r5
00026a  d002              BEQ      |L1.626|
00026c  4d73              LDR      r5,|L1.1084|
00026e  42a8              CMP      r0,r5
000270  d113              BNE      |L1.666|
                  |L1.626|
;;;315      {
;;;316        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;317        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;318        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;319        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;320        
;;;321        /* Reset the Output N Polarity level */
;;;322        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NP));
000272  f64f75f7          MOV      r5,#0xfff7
000276  402a              ANDS     r2,r2,r5
;;;323        /* Set the Output N Polarity */
;;;324        tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
000278  894d              LDRH     r5,[r1,#0xa]
00027a  432a              ORRS     r2,r2,r5
;;;325        
;;;326        /* Reset the Output N State */
;;;327        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NE));    
00027c  f64f75fb          MOV      r5,#0xfffb
000280  402a              ANDS     r2,r2,r5
;;;328        /* Set the Output N State */
;;;329        tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
000282  888d              LDRH     r5,[r1,#4]
000284  432a              ORRS     r2,r2,r5
;;;330        
;;;331        /* Reset the Output Compare and Output Compare N IDLE State */
;;;332        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1));
000286  f64f65ff          MOV      r5,#0xfeff
00028a  402b              ANDS     r3,r3,r5
;;;333        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1N));
00028c  f64f55ff          MOV      r5,#0xfdff
000290  402b              ANDS     r3,r3,r5
;;;334        
;;;335        /* Set the Output Idle state */
;;;336        tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
000292  898d              LDRH     r5,[r1,#0xc]
000294  432b              ORRS     r3,r3,r5
;;;337        /* Set the Output N Idle state */
;;;338        tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
000296  89cd              LDRH     r5,[r1,#0xe]
000298  432b              ORRS     r3,r3,r5
                  |L1.666|
;;;339      }
;;;340      /* Write to TIMx CR2 */
;;;341      TIMx->CR2 = tmpcr2;
00029a  8083              STRH     r3,[r0,#4]
;;;342      
;;;343      /* Write to TIMx CCMR1 */
;;;344      TIMx->CCMR1 = tmpccmrx;
00029c  8304              STRH     r4,[r0,#0x18]
;;;345    
;;;346      /* Set the Capture Compare Register value */
;;;347      TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse; 
00029e  88cd              LDRH     r5,[r1,#6]
0002a0  8685              STRH     r5,[r0,#0x34]
;;;348     
;;;349      /* Write to TIMx CCER */
;;;350      TIMx->CCER = tmpccer;
0002a2  8402              STRH     r2,[r0,#0x20]
;;;351    }
0002a4  bd70              POP      {r4-r6,pc}
;;;352    
                          ENDP

                  TIM_OC2Init PROC
;;;361      */
;;;362    void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
0002a6  b570              PUSH     {r4-r6,lr}
;;;363    {
;;;364      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
0002a8  2400              MOVS     r4,#0
0002aa  2200              MOVS     r2,#0
0002ac  2300              MOVS     r3,#0
;;;365       
;;;366      /* Check the parameters */
;;;367      assert_param(IS_TIM_LIST6_PERIPH(TIMx)); 
;;;368      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;369      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;370      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;371       /* Disable the Channel 2: Reset the CC2E Bit */
;;;372      TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC2E));
0002ae  8c05              LDRH     r5,[r0,#0x20]
0002b0  f64f76ef          MOV      r6,#0xffef
0002b4  4035              ANDS     r5,r5,r6
0002b6  8405              STRH     r5,[r0,#0x20]
;;;373      
;;;374      /* Get the TIMx CCER register value */  
;;;375      tmpccer = TIMx->CCER;
0002b8  8c02              LDRH     r2,[r0,#0x20]
;;;376      /* Get the TIMx CR2 register value */
;;;377      tmpcr2 =  TIMx->CR2;
0002ba  8883              LDRH     r3,[r0,#4]
;;;378      
;;;379      /* Get the TIMx CCMR1 register value */
;;;380      tmpccmrx = TIMx->CCMR1;
0002bc  8b04              LDRH     r4,[r0,#0x18]
;;;381        
;;;382      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;383      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC2M));
0002be  f64875ff          MOV      r5,#0x8fff
0002c2  402c              ANDS     r4,r4,r5
;;;384      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S));
0002c4  f64f45ff          MOV      r5,#0xfcff
0002c8  402c              ANDS     r4,r4,r5
;;;385      
;;;386      /* Select the Output Compare Mode */
;;;387      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
0002ca  880d              LDRH     r5,[r1,#0]
0002cc  f64f76ff          MOV      r6,#0xffff
0002d0  ea062505          AND      r5,r6,r5,LSL #8
0002d4  432c              ORRS     r4,r4,r5
;;;388      
;;;389      /* Reset the Output Polarity level */
;;;390      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2P));
0002d6  f64f75df          MOV      r5,#0xffdf
0002da  402a              ANDS     r2,r2,r5
;;;391      /* Set the Output Compare Polarity */
;;;392      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
0002dc  890d              LDRH     r5,[r1,#8]
0002de  ea061505          AND      r5,r6,r5,LSL #4
0002e2  432a              ORRS     r2,r2,r5
;;;393      
;;;394      /* Set the Output State */
;;;395      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
0002e4  884d              LDRH     r5,[r1,#2]
0002e6  ea061505          AND      r5,r6,r5,LSL #4
0002ea  432a              ORRS     r2,r2,r5
;;;396        
;;;397      if((TIMx == TIM1) || (TIMx == TIM8))
0002ec  4d44              LDR      r5,|L1.1024|
0002ee  42a8              CMP      r0,r5
0002f0  d002              BEQ      |L1.760|
0002f2  4d49              LDR      r5,|L1.1048|
0002f4  42a8              CMP      r0,r5
0002f6  d11d              BNE      |L1.820|
                  |L1.760|
;;;398      {
;;;399        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;400        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;401        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;402        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;403        
;;;404        /* Reset the Output N Polarity level */
;;;405        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NP));
0002f8  f64f757f          MOV      r5,#0xff7f
0002fc  402a              ANDS     r2,r2,r5
;;;406        /* Set the Output N Polarity */
;;;407        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
0002fe  894d              LDRH     r5,[r1,#0xa]
000300  f64f76ff          MOV      r6,#0xffff
000304  ea061505          AND      r5,r6,r5,LSL #4
000308  432a              ORRS     r2,r2,r5
;;;408        
;;;409        /* Reset the Output N State */
;;;410        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NE));    
00030a  f64f75bf          MOV      r5,#0xffbf
00030e  402a              ANDS     r2,r2,r5
;;;411        /* Set the Output N State */
;;;412        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
000310  888d              LDRH     r5,[r1,#4]
000312  ea061505          AND      r5,r6,r5,LSL #4
000316  432a              ORRS     r2,r2,r5
;;;413        
;;;414        /* Reset the Output Compare and Output Compare N IDLE State */
;;;415        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2));
000318  f64f35ff          MOV      r5,#0xfbff
00031c  402b              ANDS     r3,r3,r5
;;;416        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2N));
00031e  f24f75ff          MOV      r5,#0xf7ff
000322  402b              ANDS     r3,r3,r5
;;;417        
;;;418        /* Set the Output Idle state */
;;;419        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
000324  898d              LDRH     r5,[r1,#0xc]
000326  ea060585          AND      r5,r6,r5,LSL #2
00032a  432b              ORRS     r3,r3,r5
;;;420        /* Set the Output N Idle state */
;;;421        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
00032c  89cd              LDRH     r5,[r1,#0xe]
00032e  ea060585          AND      r5,r6,r5,LSL #2
000332  432b              ORRS     r3,r3,r5
                  |L1.820|
;;;422      }
;;;423      /* Write to TIMx CR2 */
;;;424      TIMx->CR2 = tmpcr2;
000334  8083              STRH     r3,[r0,#4]
;;;425      
;;;426      /* Write to TIMx CCMR1 */
;;;427      TIMx->CCMR1 = tmpccmrx;
000336  8304              STRH     r4,[r0,#0x18]
;;;428    
;;;429      /* Set the Capture Compare Register value */
;;;430      TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
000338  88cd              LDRH     r5,[r1,#6]
00033a  8705              STRH     r5,[r0,#0x38]
;;;431      
;;;432      /* Write to TIMx CCER */
;;;433      TIMx->CCER = tmpccer;
00033c  8402              STRH     r2,[r0,#0x20]
;;;434    }
00033e  bd70              POP      {r4-r6,pc}
;;;435    
                          ENDP

                  TIM_OC3Init PROC
;;;443      */
;;;444    void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000340  b570              PUSH     {r4-r6,lr}
;;;445    {
;;;446      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000342  2400              MOVS     r4,#0
000344  2200              MOVS     r2,#0
000346  2300              MOVS     r3,#0
;;;447       
;;;448      /* Check the parameters */
;;;449      assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;450      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;451      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;452      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;453      /* Disable the Channel 2: Reset the CC2E Bit */
;;;454      TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC3E));
000348  8c05              LDRH     r5,[r0,#0x20]
00034a  f64f66ff          MOV      r6,#0xfeff
00034e  4035              ANDS     r5,r5,r6
000350  8405              STRH     r5,[r0,#0x20]
;;;455      
;;;456      /* Get the TIMx CCER register value */
;;;457      tmpccer = TIMx->CCER;
000352  8c02              LDRH     r2,[r0,#0x20]
;;;458      /* Get the TIMx CR2 register value */
;;;459      tmpcr2 =  TIMx->CR2;
000354  8883              LDRH     r3,[r0,#4]
;;;460      
;;;461      /* Get the TIMx CCMR2 register value */
;;;462      tmpccmrx = TIMx->CCMR2;
000356  8b84              LDRH     r4,[r0,#0x1c]
;;;463        
;;;464      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;465      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC3M));
000358  f64f758f          MOV      r5,#0xff8f
00035c  402c              ANDS     r4,r4,r5
;;;466      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC3S));  
00035e  f64f75fc          MOV      r5,#0xfffc
000362  402c              ANDS     r4,r4,r5
;;;467      /* Select the Output Compare Mode */
;;;468      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
000364  880d              LDRH     r5,[r1,#0]
000366  432c              ORRS     r4,r4,r5
;;;469      
;;;470      /* Reset the Output Polarity level */
;;;471      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3P));
000368  f64f55ff          MOV      r5,#0xfdff
00036c  402a              ANDS     r2,r2,r5
;;;472      /* Set the Output Compare Polarity */
;;;473      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
00036e  890d              LDRH     r5,[r1,#8]
000370  f64f76ff          MOV      r6,#0xffff
000374  ea062505          AND      r5,r6,r5,LSL #8
000378  432a              ORRS     r2,r2,r5
;;;474      
;;;475      /* Set the Output State */
;;;476      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
00037a  884d              LDRH     r5,[r1,#2]
00037c  ea062505          AND      r5,r6,r5,LSL #8
000380  432a              ORRS     r2,r2,r5
;;;477        
;;;478      if((TIMx == TIM1) || (TIMx == TIM8))
000382  4d1f              LDR      r5,|L1.1024|
000384  42a8              CMP      r0,r5
000386  d002              BEQ      |L1.910|
000388  4d23              LDR      r5,|L1.1048|
00038a  42a8              CMP      r0,r5
00038c  d11d              BNE      |L1.970|
                  |L1.910|
;;;479      {
;;;480        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;481        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;482        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;483        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;484        
;;;485        /* Reset the Output N Polarity level */
;;;486        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NP));
00038e  f24f75ff          MOV      r5,#0xf7ff
000392  402a              ANDS     r2,r2,r5
;;;487        /* Set the Output N Polarity */
;;;488        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
000394  894d              LDRH     r5,[r1,#0xa]
000396  f64f76ff          MOV      r6,#0xffff
00039a  ea062505          AND      r5,r6,r5,LSL #8
00039e  432a              ORRS     r2,r2,r5
;;;489        /* Reset the Output N State */
;;;490        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NE));
0003a0  f64f35ff          MOV      r5,#0xfbff
0003a4  402a              ANDS     r2,r2,r5
;;;491        
;;;492        /* Set the Output N State */
;;;493        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
0003a6  888d              LDRH     r5,[r1,#4]
0003a8  ea062505          AND      r5,r6,r5,LSL #8
0003ac  432a              ORRS     r2,r2,r5
;;;494        /* Reset the Output Compare and Output Compare N IDLE State */
;;;495        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3));
0003ae  f64e75ff          MOV      r5,#0xefff
0003b2  402b              ANDS     r3,r3,r5
;;;496        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3N));
0003b4  f64d75ff          MOV      r5,#0xdfff
0003b8  402b              ANDS     r3,r3,r5
;;;497        /* Set the Output Idle state */
;;;498        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
0003ba  898d              LDRH     r5,[r1,#0xc]
0003bc  ea061505          AND      r5,r6,r5,LSL #4
0003c0  432b              ORRS     r3,r3,r5
;;;499        /* Set the Output N Idle state */
;;;500        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
0003c2  89cd              LDRH     r5,[r1,#0xe]
0003c4  ea061505          AND      r5,r6,r5,LSL #4
0003c8  432b              ORRS     r3,r3,r5
                  |L1.970|
;;;501      }
;;;502      /* Write to TIMx CR2 */
;;;503      TIMx->CR2 = tmpcr2;
0003ca  8083              STRH     r3,[r0,#4]
;;;504      
;;;505      /* Write to TIMx CCMR2 */
;;;506      TIMx->CCMR2 = tmpccmrx;
0003cc  8384              STRH     r4,[r0,#0x1c]
;;;507    
;;;508      /* Set the Capture Compare Register value */
;;;509      TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
0003ce  88cd              LDRH     r5,[r1,#6]
0003d0  8785              STRH     r5,[r0,#0x3c]
;;;510      
;;;511      /* Write to TIMx CCER */
;;;512      TIMx->CCER = tmpccer;
0003d2  8402              STRH     r2,[r0,#0x20]
;;;513    }
0003d4  bd70              POP      {r4-r6,pc}
;;;514    
                          ENDP

                  TIM_OC4Init PROC
;;;522      */
;;;523    void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
0003d6  b570              PUSH     {r4-r6,lr}
;;;524    {
;;;525      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
0003d8  2200              MOVS     r2,#0
0003da  2300              MOVS     r3,#0
0003dc  2400              MOVS     r4,#0
;;;526       
;;;527      /* Check the parameters */
;;;528      assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;529      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;530      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;531      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;532      /* Disable the Channel 2: Reset the CC4E Bit */
;;;533      TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC4E));
0003de  8c05              LDRH     r5,[r0,#0x20]
0003e0  f64e76ff          MOV      r6,#0xefff
0003e4  4035              ANDS     r5,r5,r6
0003e6  8405              STRH     r5,[r0,#0x20]
;;;534      
;;;535      /* Get the TIMx CCER register value */
;;;536      tmpccer = TIMx->CCER;
0003e8  8c03              LDRH     r3,[r0,#0x20]
;;;537      /* Get the TIMx CR2 register value */
;;;538      tmpcr2 =  TIMx->CR2;
0003ea  8884              LDRH     r4,[r0,#4]
;;;539      
;;;540      /* Get the TIMx CCMR2 register value */
;;;541      tmpccmrx = TIMx->CCMR2;
0003ec  8b82              LDRH     r2,[r0,#0x1c]
;;;542        
;;;543      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;544      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC4M));
0003ee  f64875ff          MOV      r5,#0x8fff
0003f2  402a              ANDS     r2,r2,r5
;;;545      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC4S));
0003f4  f64f45ff          MOV      r5,#0xfcff
0003f8  402a              ANDS     r2,r2,r5
;;;546      
;;;547      /* Select the Output Compare Mode */
;;;548      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
0003fa  880d              LDRH     r5,[r1,#0]
0003fc  e020              B        |L1.1088|
0003fe  0000              DCW      0x0000
                  |L1.1024|
                          DCD      0x40012c00
                  |L1.1028|
                          DCD      0x40000400
                  |L1.1032|
                          DCD      0x40000800
                  |L1.1036|
                          DCD      0x40000c00
                  |L1.1040|
                          DCD      0x40001000
                  |L1.1044|
                          DCD      0x40001400
                  |L1.1048|
                          DCD      0x40013400
                  |L1.1052|
                          DCD      0x40014c00
                  |L1.1056|
                          DCD      0x40015000
                  |L1.1060|
                          DCD      0x40015400
                  |L1.1064|
                          DCD      0x40001800
                  |L1.1068|
                          DCD      0x40001c00
                  |L1.1072|
                          DCD      0x40002000
                  |L1.1076|
                          DCD      0x40014000
                  |L1.1080|
                          DCD      0x40014400
                  |L1.1084|
                          DCD      0x40014800
                  |L1.1088|
000440  f64f76ff          MOV      r6,#0xffff
000444  ea062505          AND      r5,r6,r5,LSL #8
000448  432a              ORRS     r2,r2,r5
;;;549      
;;;550      /* Reset the Output Polarity level */
;;;551      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC4P));
00044a  f64d75ff          MOV      r5,#0xdfff
00044e  402b              ANDS     r3,r3,r5
;;;552      /* Set the Output Compare Polarity */
;;;553      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
000450  890d              LDRH     r5,[r1,#8]
000452  ea063505          AND      r5,r6,r5,LSL #12
000456  432b              ORRS     r3,r3,r5
;;;554      
;;;555      /* Set the Output State */
;;;556      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
000458  884d              LDRH     r5,[r1,#2]
00045a  ea063505          AND      r5,r6,r5,LSL #12
00045e  432b              ORRS     r3,r3,r5
;;;557        
;;;558      if((TIMx == TIM1) || (TIMx == TIM8))
000460  4dfa              LDR      r5,|L1.2124|
000462  42a8              CMP      r0,r5
000464  d002              BEQ      |L1.1132|
000466  4dfa              LDR      r5,|L1.2128|
000468  42a8              CMP      r0,r5
00046a  d108              BNE      |L1.1150|
                  |L1.1132|
;;;559      {
;;;560        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;561        /* Reset the Output Compare IDLE State */
;;;562        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS4));
00046c  f64b75ff          MOV      r5,#0xbfff
000470  402c              ANDS     r4,r4,r5
;;;563        /* Set the Output Idle state */
;;;564        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
000472  898d              LDRH     r5,[r1,#0xc]
000474  f64f76ff          MOV      r6,#0xffff
000478  ea061585          AND      r5,r6,r5,LSL #6
00047c  432c              ORRS     r4,r4,r5
                  |L1.1150|
;;;565      }
;;;566      /* Write to TIMx CR2 */
;;;567      TIMx->CR2 = tmpcr2;
00047e  8084              STRH     r4,[r0,#4]
;;;568      
;;;569      /* Write to TIMx CCMR2 */  
;;;570      TIMx->CCMR2 = tmpccmrx;
000480  8382              STRH     r2,[r0,#0x1c]
;;;571    
;;;572      /* Set the Capture Compare Register value */
;;;573      TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
000482  88cd              LDRH     r5,[r1,#6]
000484  f8a05040          STRH     r5,[r0,#0x40]
;;;574      
;;;575      /* Write to TIMx CCER */
;;;576      TIMx->CCER = tmpccer;
000488  8403              STRH     r3,[r0,#0x20]
;;;577    }
00048a  bd70              POP      {r4-r6,pc}
;;;578    
                          ENDP

                  TIM_SetIC4Prescaler PROC
;;;2418     */
;;;2419   void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
00048c  8b82              LDRH     r2,[r0,#0x1c]
;;;2420   {  
;;;2421     /* Check the parameters */
;;;2422     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2423     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2424     /* Reset the IC4PSC Bits */
;;;2425     TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC4PSC);
00048e  f24f33ff          MOV      r3,#0xf3ff
000492  401a              ANDS     r2,r2,r3
000494  8382              STRH     r2,[r0,#0x1c]
;;;2426     /* Set the IC4PSC value */
;;;2427     TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
000496  8b82              LDRH     r2,[r0,#0x1c]
000498  f64f73ff          MOV      r3,#0xffff
00049c  ea032301          AND      r3,r3,r1,LSL #8
0004a0  431a              ORRS     r2,r2,r3
0004a2  8382              STRH     r2,[r0,#0x1c]
;;;2428   }
0004a4  4770              BX       lr
;;;2429   
                          ENDP

                  TI4_Config PROC
;;;2844     */
;;;2845   static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
0004a6  b5f0              PUSH     {r4-r7,lr}
;;;2846                          uint16_t TIM_ICFilter)
;;;2847   {
0004a8  460c              MOV      r4,r1
0004aa  4615              MOV      r5,r2
;;;2848     uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
0004ac  2200              MOVS     r2,#0
0004ae  2100              MOVS     r1,#0
0004b0  2600              MOVS     r6,#0
;;;2849   
;;;2850      /* Disable the Channel 4: Reset the CC4E Bit */
;;;2851     TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC4E);
0004b2  8c07              LDRH     r7,[r0,#0x20]
0004b4  f64e7cff          MOV      r12,#0xefff
0004b8  ea07070c          AND      r7,r7,r12
0004bc  8407              STRH     r7,[r0,#0x20]
;;;2852     tmpccmr2 = TIMx->CCMR2;
0004be  8b82              LDRH     r2,[r0,#0x1c]
;;;2853     tmpccer = TIMx->CCER;
0004c0  8c01              LDRH     r1,[r0,#0x20]
;;;2854     tmp = (uint16_t)(TIM_ICPolarity << 12);
0004c2  f64f77ff          MOV      r7,#0xffff
0004c6  ea073604          AND      r6,r7,r4,LSL #12
;;;2855     /* Select the Input and set the filter */
;;;2856     tmpccmr2 &= (uint16_t)((uint16_t)(~(uint16_t)TIM_CCMR2_CC4S) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC4F)));
0004ca  f64047ff          MOV      r7,#0xcff
0004ce  403a              ANDS     r2,r2,r7
;;;2857     tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
0004d0  f64f77ff          MOV      r7,#0xffff
0004d4  ea072705          AND      r7,r7,r5,LSL #8
0004d8  433a              ORRS     r2,r2,r7
;;;2858     tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);
0004da  f64f77ff          MOV      r7,#0xffff
0004de  ea073703          AND      r7,r7,r3,LSL #12
0004e2  433a              ORRS     r2,r2,r7
;;;2859     
;;;2860     if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
0004e4  4fd9              LDR      r7,|L1.2124|
0004e6  42b8              CMP      r0,r7
0004e8  d00e              BEQ      |L1.1288|
0004ea  4fd9              LDR      r7,|L1.2128|
0004ec  42b8              CMP      r0,r7
0004ee  d00b              BEQ      |L1.1288|
0004f0  f1b04f80          CMP      r0,#0x40000000
0004f4  d008              BEQ      |L1.1288|
0004f6  4fd7              LDR      r7,|L1.2132|
0004f8  42b8              CMP      r0,r7
0004fa  d005              BEQ      |L1.1288|
;;;2861        (TIMx == TIM4) ||(TIMx == TIM5))
0004fc  4fd6              LDR      r7,|L1.2136|
0004fe  42b8              CMP      r0,r7
000500  d002              BEQ      |L1.1288|
000502  4fd6              LDR      r7,|L1.2140|
000504  42b8              CMP      r0,r7
000506  d106              BNE      |L1.1302|
                  |L1.1288|
;;;2862     {
;;;2863       /* Select the Polarity and set the CC4E Bit */
;;;2864       tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC4P));
000508  f64d77ff          MOV      r7,#0xdfff
00050c  4039              ANDS     r1,r1,r7
;;;2865       tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
00050e  f4465780          ORR      r7,r6,#0x1000
000512  4339              ORRS     r1,r1,r7
000514  e005              B        |L1.1314|
                  |L1.1302|
;;;2866     }
;;;2867     else
;;;2868     {
;;;2869       /* Select the Polarity and set the CC4E Bit */
;;;2870       tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P | TIM_CCER_CC4NP));
000516  f64757ff          MOV      r7,#0x7dff
00051a  4039              ANDS     r1,r1,r7
;;;2871       tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC4E);
00051c  f4445780          ORR      r7,r4,#0x1000
000520  4339              ORRS     r1,r1,r7
                  |L1.1314|
;;;2872     }
;;;2873     /* Write to TIMx CCMR2 and CCER registers */
;;;2874     TIMx->CCMR2 = tmpccmr2;
000522  8382              STRH     r2,[r0,#0x1c]
;;;2875     TIMx->CCER = tmpccer;
000524  8401              STRH     r1,[r0,#0x20]
;;;2876   }
000526  bdf0              POP      {r4-r7,pc}
;;;2877   
                          ENDP

                  TIM_SetIC3Prescaler PROC
;;;2396     */
;;;2397   void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000528  8b82              LDRH     r2,[r0,#0x1c]
;;;2398   {
;;;2399     /* Check the parameters */
;;;2400     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2401     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2402     /* Reset the IC3PSC Bits */
;;;2403     TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC3PSC);
00052a  f64f73f3          MOV      r3,#0xfff3
00052e  401a              ANDS     r2,r2,r3
000530  8382              STRH     r2,[r0,#0x1c]
;;;2404     /* Set the IC3PSC value */
;;;2405     TIMx->CCMR2 |= TIM_ICPSC;
000532  8b82              LDRH     r2,[r0,#0x1c]
000534  430a              ORRS     r2,r2,r1
000536  8382              STRH     r2,[r0,#0x1c]
;;;2406   }
000538  4770              BX       lr
;;;2407   
                          ENDP

                  TI3_Config PROC
;;;2796     */
;;;2797   static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
00053a  b5f0              PUSH     {r4-r7,lr}
;;;2798                          uint16_t TIM_ICFilter)
;;;2799   {
00053c  460c              MOV      r4,r1
00053e  4615              MOV      r5,r2
;;;2800     uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
000540  2200              MOVS     r2,#0
000542  2100              MOVS     r1,#0
000544  2600              MOVS     r6,#0
;;;2801     /* Disable the Channel 3: Reset the CC3E Bit */
;;;2802     TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC3E);
000546  8c07              LDRH     r7,[r0,#0x20]
000548  f64f6cff          MOV      r12,#0xfeff
00054c  ea07070c          AND      r7,r7,r12
000550  8407              STRH     r7,[r0,#0x20]
;;;2803     tmpccmr2 = TIMx->CCMR2;
000552  8b82              LDRH     r2,[r0,#0x1c]
;;;2804     tmpccer = TIMx->CCER;
000554  8c01              LDRH     r1,[r0,#0x20]
;;;2805     tmp = (uint16_t)(TIM_ICPolarity << 8);
000556  f64f77ff          MOV      r7,#0xffff
00055a  ea072604          AND      r6,r7,r4,LSL #8
;;;2806     /* Select the Input and set the filter */
;;;2807     tmpccmr2 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR2_CC3S)) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC3F)));
00055e  f64f770c          MOV      r7,#0xff0c
000562  403a              ANDS     r2,r2,r7
;;;2808     tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
000564  f64f77ff          MOV      r7,#0xffff
000568  ea071703          AND      r7,r7,r3,LSL #4
00056c  432f              ORRS     r7,r7,r5
00056e  433a              ORRS     r2,r2,r7
;;;2809       
;;;2810     if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
000570  4fb6              LDR      r7,|L1.2124|
000572  42b8              CMP      r0,r7
000574  d00e              BEQ      |L1.1428|
000576  4fb6              LDR      r7,|L1.2128|
000578  42b8              CMP      r0,r7
00057a  d00b              BEQ      |L1.1428|
00057c  f1b04f80          CMP      r0,#0x40000000
000580  d008              BEQ      |L1.1428|
000582  4fb4              LDR      r7,|L1.2132|
000584  42b8              CMP      r0,r7
000586  d005              BEQ      |L1.1428|
;;;2811        (TIMx == TIM4) ||(TIMx == TIM5))
000588  4fb3              LDR      r7,|L1.2136|
00058a  42b8              CMP      r0,r7
00058c  d002              BEQ      |L1.1428|
00058e  4fb3              LDR      r7,|L1.2140|
000590  42b8              CMP      r0,r7
000592  d106              BNE      |L1.1442|
                  |L1.1428|
;;;2812     {
;;;2813       /* Select the Polarity and set the CC3E Bit */
;;;2814       tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P));
000594  f64f57ff          MOV      r7,#0xfdff
000598  4039              ANDS     r1,r1,r7
;;;2815       tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);
00059a  f4467780          ORR      r7,r6,#0x100
00059e  4339              ORRS     r1,r1,r7
0005a0  e005              B        |L1.1454|
                  |L1.1442|
;;;2816     }
;;;2817     else
;;;2818     {
;;;2819       /* Select the Polarity and set the CC3E Bit */
;;;2820       tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P | TIM_CCER_CC3NP));
0005a2  f24f57ff          MOV      r7,#0xf5ff
0005a6  4039              ANDS     r1,r1,r7
;;;2821       tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC3E);
0005a8  f4447780          ORR      r7,r4,#0x100
0005ac  4339              ORRS     r1,r1,r7
                  |L1.1454|
;;;2822     }
;;;2823     
;;;2824     /* Write to TIMx CCMR2 and CCER registers */
;;;2825     TIMx->CCMR2 = tmpccmr2;
0005ae  8382              STRH     r2,[r0,#0x1c]
;;;2826     TIMx->CCER = tmpccer;
0005b0  8401              STRH     r1,[r0,#0x20]
;;;2827   }
0005b2  bdf0              POP      {r4-r7,pc}
;;;2828   
                          ENDP

                  TIM_SetIC2Prescaler PROC
;;;2374     */
;;;2375   void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
0005b4  8b02              LDRH     r2,[r0,#0x18]
;;;2376   {
;;;2377     /* Check the parameters */
;;;2378     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2379     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2380     /* Reset the IC2PSC Bits */
;;;2381     TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC2PSC);
0005b6  f24f33ff          MOV      r3,#0xf3ff
0005ba  401a              ANDS     r2,r2,r3
0005bc  8302              STRH     r2,[r0,#0x18]
;;;2382     /* Set the IC2PSC value */
;;;2383     TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
0005be  8b02              LDRH     r2,[r0,#0x18]
0005c0  f64f73ff          MOV      r3,#0xffff
0005c4  ea032301          AND      r3,r3,r1,LSL #8
0005c8  431a              ORRS     r2,r2,r3
0005ca  8302              STRH     r2,[r0,#0x18]
;;;2384   }
0005cc  4770              BX       lr
;;;2385   
                          ENDP

                  TI2_Config PROC
;;;2747     */
;;;2748   static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
0005ce  b5f0              PUSH     {r4-r7,lr}
;;;2749                          uint16_t TIM_ICFilter)
;;;2750   {
0005d0  460c              MOV      r4,r1
0005d2  4615              MOV      r5,r2
;;;2751     uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
0005d4  2200              MOVS     r2,#0
0005d6  2100              MOVS     r1,#0
0005d8  2600              MOVS     r6,#0
;;;2752     /* Disable the Channel 2: Reset the CC2E Bit */
;;;2753     TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);
0005da  8c07              LDRH     r7,[r0,#0x20]
0005dc  f64f7cef          MOV      r12,#0xffef
0005e0  ea07070c          AND      r7,r7,r12
0005e4  8407              STRH     r7,[r0,#0x20]
;;;2754     tmpccmr1 = TIMx->CCMR1;
0005e6  8b02              LDRH     r2,[r0,#0x18]
;;;2755     tmpccer = TIMx->CCER;
0005e8  8c01              LDRH     r1,[r0,#0x20]
;;;2756     tmp = (uint16_t)(TIM_ICPolarity << 4);
0005ea  f64f77ff          MOV      r7,#0xffff
0005ee  ea071604          AND      r6,r7,r4,LSL #4
;;;2757     /* Select the Input and set the filter */
;;;2758     tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
0005f2  f64047ff          MOV      r7,#0xcff
0005f6  403a              ANDS     r2,r2,r7
;;;2759     tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
0005f8  f64f77ff          MOV      r7,#0xffff
0005fc  ea073703          AND      r7,r7,r3,LSL #12
000600  433a              ORRS     r2,r2,r7
;;;2760     tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
000602  f64f77ff          MOV      r7,#0xffff
000606  ea072705          AND      r7,r7,r5,LSL #8
00060a  433a              ORRS     r2,r2,r7
;;;2761     
;;;2762     if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
00060c  4f8f              LDR      r7,|L1.2124|
00060e  42b8              CMP      r0,r7
000610  d00e              BEQ      |L1.1584|
000612  4f8f              LDR      r7,|L1.2128|
000614  42b8              CMP      r0,r7
000616  d00b              BEQ      |L1.1584|
000618  f1b04f80          CMP      r0,#0x40000000
00061c  d008              BEQ      |L1.1584|
00061e  4f8d              LDR      r7,|L1.2132|
000620  42b8              CMP      r0,r7
000622  d005              BEQ      |L1.1584|
;;;2763        (TIMx == TIM4) ||(TIMx == TIM5))
000624  4f8c              LDR      r7,|L1.2136|
000626  42b8              CMP      r0,r7
000628  d002              BEQ      |L1.1584|
00062a  4f8c              LDR      r7,|L1.2140|
00062c  42b8              CMP      r0,r7
00062e  d106              BNE      |L1.1598|
                  |L1.1584|
;;;2764     {
;;;2765       /* Select the Polarity and set the CC2E Bit */
;;;2766       tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P));
000630  f64f77df          MOV      r7,#0xffdf
000634  4039              ANDS     r1,r1,r7
;;;2767       tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
000636  f0460710          ORR      r7,r6,#0x10
00063a  4339              ORRS     r1,r1,r7
00063c  e005              B        |L1.1610|
                  |L1.1598|
;;;2768     }
;;;2769     else
;;;2770     {
;;;2771       /* Select the Polarity and set the CC2E Bit */
;;;2772       tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P | TIM_CCER_CC2NP));
00063e  f64f775f          MOV      r7,#0xff5f
000642  4039              ANDS     r1,r1,r7
;;;2773       tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC2E);
000644  f0440710          ORR      r7,r4,#0x10
000648  4339              ORRS     r1,r1,r7
                  |L1.1610|
;;;2774     }
;;;2775     
;;;2776     /* Write to TIMx CCMR1 and CCER registers */
;;;2777     TIMx->CCMR1 = tmpccmr1 ;
00064a  8302              STRH     r2,[r0,#0x18]
;;;2778     TIMx->CCER = tmpccer;
00064c  8401              STRH     r1,[r0,#0x20]
;;;2779   }
00064e  bdf0              POP      {r4-r7,pc}
;;;2780   
                          ENDP

                  TIM_SetIC1Prescaler PROC
;;;2352     */
;;;2353   void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000650  8b02              LDRH     r2,[r0,#0x18]
;;;2354   {
;;;2355     /* Check the parameters */
;;;2356     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;2357     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2358     /* Reset the IC1PSC Bits */
;;;2359     TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC1PSC);
000652  f64f73f3          MOV      r3,#0xfff3
000656  401a              ANDS     r2,r2,r3
000658  8302              STRH     r2,[r0,#0x18]
;;;2360     /* Set the IC1PSC value */
;;;2361     TIMx->CCMR1 |= TIM_ICPSC;
00065a  8b02              LDRH     r2,[r0,#0x18]
00065c  430a              ORRS     r2,r2,r1
00065e  8302              STRH     r2,[r0,#0x18]
;;;2362   }
000660  4770              BX       lr
;;;2363   
                          ENDP

                  TI1_Config PROC
;;;2700     */
;;;2701   static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000662  b5f0              PUSH     {r4-r7,lr}
;;;2702                          uint16_t TIM_ICFilter)
;;;2703   {
000664  460c              MOV      r4,r1
000666  4615              MOV      r5,r2
;;;2704     uint16_t tmpccmr1 = 0, tmpccer = 0;
000668  2200              MOVS     r2,#0
00066a  2100              MOVS     r1,#0
;;;2705     /* Disable the Channel 1: Reset the CC1E Bit */
;;;2706     TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC1E);
00066c  8c06              LDRH     r6,[r0,#0x20]
00066e  f64f77fe          MOV      r7,#0xfffe
000672  403e              ANDS     r6,r6,r7
000674  8406              STRH     r6,[r0,#0x20]
;;;2707     tmpccmr1 = TIMx->CCMR1;
000676  8b02              LDRH     r2,[r0,#0x18]
;;;2708     tmpccer = TIMx->CCER;
000678  8c01              LDRH     r1,[r0,#0x20]
;;;2709     /* Select the Input and set the filter */
;;;2710     tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC1F)));
00067a  f64f760c          MOV      r6,#0xff0c
00067e  4032              ANDS     r2,r2,r6
;;;2711     tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
000680  1c7e              ADDS     r6,r7,#1
000682  ea061603          AND      r6,r6,r3,LSL #4
000686  432e              ORRS     r6,r6,r5
000688  4332              ORRS     r2,r2,r6
;;;2712     
;;;2713     if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
00068a  4e70              LDR      r6,|L1.2124|
00068c  42b0              CMP      r0,r6
00068e  d00e              BEQ      |L1.1710|
000690  4e6f              LDR      r6,|L1.2128|
000692  42b0              CMP      r0,r6
000694  d00b              BEQ      |L1.1710|
000696  f1b04f80          CMP      r0,#0x40000000
00069a  d008              BEQ      |L1.1710|
00069c  4e6d              LDR      r6,|L1.2132|
00069e  42b0              CMP      r0,r6
0006a0  d005              BEQ      |L1.1710|
;;;2714        (TIMx == TIM4) ||(TIMx == TIM5))
0006a2  4e6d              LDR      r6,|L1.2136|
0006a4  42b0              CMP      r0,r6
0006a6  d002              BEQ      |L1.1710|
0006a8  4e6c              LDR      r6,|L1.2140|
0006aa  42b0              CMP      r0,r6
0006ac  d106              BNE      |L1.1724|
                  |L1.1710|
;;;2715     {
;;;2716       /* Select the Polarity and set the CC1E Bit */
;;;2717       tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P));
0006ae  f64f76fd          MOV      r6,#0xfffd
0006b2  4031              ANDS     r1,r1,r6
;;;2718       tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
0006b4  f0440601          ORR      r6,r4,#1
0006b8  4331              ORRS     r1,r1,r6
0006ba  e005              B        |L1.1736|
                  |L1.1724|
;;;2719     }
;;;2720     else
;;;2721     {
;;;2722       /* Select the Polarity and set the CC1E Bit */
;;;2723       tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P | TIM_CCER_CC1NP));
0006bc  f64f76f5          MOV      r6,#0xfff5
0006c0  4031              ANDS     r1,r1,r6
;;;2724       tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
0006c2  f0440601          ORR      r6,r4,#1
0006c6  4331              ORRS     r1,r1,r6
                  |L1.1736|
;;;2725     }
;;;2726   
;;;2727     /* Write to TIMx CCMR1 and CCER registers */
;;;2728     TIMx->CCMR1 = tmpccmr1;
0006c8  8302              STRH     r2,[r0,#0x18]
;;;2729     TIMx->CCER = tmpccer;
0006ca  8401              STRH     r1,[r0,#0x20]
;;;2730   }
0006cc  bdf0              POP      {r4-r7,pc}
;;;2731   
                          ENDP

                  TIM_ICInit PROC
;;;586      */
;;;587    void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
0006ce  b570              PUSH     {r4-r6,lr}
;;;588    {
0006d0  4605              MOV      r5,r0
0006d2  460c              MOV      r4,r1
;;;589      /* Check the parameters */
;;;590      assert_param(IS_TIM_CHANNEL(TIM_ICInitStruct->TIM_Channel));  
;;;591      assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
;;;592      assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
;;;593      assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
;;;594      
;;;595      if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
0006d4  485d              LDR      r0,|L1.2124|
0006d6  4285              CMP      r5,r0
0006d8  d00e              BEQ      |L1.1784|
0006da  485d              LDR      r0,|L1.2128|
0006dc  4285              CMP      r5,r0
0006de  d00b              BEQ      |L1.1784|
0006e0  f1b54f80          CMP      r5,#0x40000000
0006e4  d008              BEQ      |L1.1784|
0006e6  485b              LDR      r0,|L1.2132|
0006e8  4285              CMP      r5,r0
0006ea  d005              BEQ      |L1.1784|
;;;596         (TIMx == TIM4) ||(TIMx == TIM5))
0006ec  485a              LDR      r0,|L1.2136|
0006ee  4285              CMP      r5,r0
0006f0  d002              BEQ      |L1.1784|
0006f2  485a              LDR      r0,|L1.2140|
0006f4  4285              CMP      r5,r0
0006f6  d100              BNE      |L1.1786|
                  |L1.1784|
;;;597      {
;;;598        assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
0006f8  e000              B        |L1.1788|
                  |L1.1786|
;;;599      }
;;;600      else
;;;601      {
;;;602        assert_param(IS_TIM_IC_POLARITY_LITE(TIM_ICInitStruct->TIM_ICPolarity));
0006fa  bf00              NOP      
                  |L1.1788|
;;;603      }
;;;604      if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
0006fc  8820              LDRH     r0,[r4,#0]
0006fe  b950              CBNZ     r0,|L1.1814|
;;;605      {
;;;606        assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;607        /* TI1 Configuration */
;;;608        TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000700  8923              LDRH     r3,[r4,#8]
000702  88a2              LDRH     r2,[r4,#4]
000704  8861              LDRH     r1,[r4,#2]
000706  4628              MOV      r0,r5
000708  f7fffffe          BL       TI1_Config
;;;609                   TIM_ICInitStruct->TIM_ICSelection,
;;;610                   TIM_ICInitStruct->TIM_ICFilter);
;;;611        /* Set the Input Capture Prescaler value */
;;;612        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00070c  88e1              LDRH     r1,[r4,#6]
00070e  4628              MOV      r0,r5
000710  f7fffffe          BL       TIM_SetIC1Prescaler
000714  e025              B        |L1.1890|
                  |L1.1814|
;;;613      }
;;;614      else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
000716  8820              LDRH     r0,[r4,#0]
000718  2804              CMP      r0,#4
00071a  d10a              BNE      |L1.1842|
;;;615      {
;;;616        assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;617        /* TI2 Configuration */
;;;618        TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
00071c  8923              LDRH     r3,[r4,#8]
00071e  88a2              LDRH     r2,[r4,#4]
000720  8861              LDRH     r1,[r4,#2]
000722  4628              MOV      r0,r5
000724  f7fffffe          BL       TI2_Config
;;;619                   TIM_ICInitStruct->TIM_ICSelection,
;;;620                   TIM_ICInitStruct->TIM_ICFilter);
;;;621        /* Set the Input Capture Prescaler value */
;;;622        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000728  88e1              LDRH     r1,[r4,#6]
00072a  4628              MOV      r0,r5
00072c  f7fffffe          BL       TIM_SetIC2Prescaler
000730  e017              B        |L1.1890|
                  |L1.1842|
;;;623      }
;;;624      else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
000732  8820              LDRH     r0,[r4,#0]
000734  2808              CMP      r0,#8
000736  d10a              BNE      |L1.1870|
;;;625      {
;;;626        assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;627        /* TI3 Configuration */
;;;628        TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
000738  8923              LDRH     r3,[r4,#8]
00073a  88a2              LDRH     r2,[r4,#4]
00073c  8861              LDRH     r1,[r4,#2]
00073e  4628              MOV      r0,r5
000740  f7fffffe          BL       TI3_Config
;;;629                   TIM_ICInitStruct->TIM_ICSelection,
;;;630                   TIM_ICInitStruct->TIM_ICFilter);
;;;631        /* Set the Input Capture Prescaler value */
;;;632        TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000744  88e1              LDRH     r1,[r4,#6]
000746  4628              MOV      r0,r5
000748  f7fffffe          BL       TIM_SetIC3Prescaler
00074c  e009              B        |L1.1890|
                  |L1.1870|
;;;633      }
;;;634      else
;;;635      {
;;;636        assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;637        /* TI4 Configuration */
;;;638        TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
00074e  8923              LDRH     r3,[r4,#8]
000750  88a2              LDRH     r2,[r4,#4]
000752  8861              LDRH     r1,[r4,#2]
000754  4628              MOV      r0,r5
000756  f7fffffe          BL       TI4_Config
;;;639                   TIM_ICInitStruct->TIM_ICSelection,
;;;640                   TIM_ICInitStruct->TIM_ICFilter);
;;;641        /* Set the Input Capture Prescaler value */
;;;642        TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00075a  88e1              LDRH     r1,[r4,#6]
00075c  4628              MOV      r0,r5
00075e  f7fffffe          BL       TIM_SetIC4Prescaler
                  |L1.1890|
;;;643      }
;;;644    }
000762  bd70              POP      {r4-r6,pc}
;;;645    
                          ENDP

                  TIM_PWMIConfig PROC
;;;653      */
;;;654    void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000764  e92d41f0          PUSH     {r4-r8,lr}
;;;655    {
000768  4605              MOV      r5,r0
00076a  460c              MOV      r4,r1
;;;656      uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
00076c  2600              MOVS     r6,#0
;;;657      uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
00076e  2701              MOVS     r7,#1
;;;658      /* Check the parameters */
;;;659      assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;660      /* Select the Opposite Input Polarity */
;;;661      if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
000770  8860              LDRH     r0,[r4,#2]
000772  b908              CBNZ     r0,|L1.1912|
;;;662      {
;;;663        icoppositepolarity = TIM_ICPolarity_Falling;
000774  2602              MOVS     r6,#2
000776  e000              B        |L1.1914|
                  |L1.1912|
;;;664      }
;;;665      else
;;;666      {
;;;667        icoppositepolarity = TIM_ICPolarity_Rising;
000778  2600              MOVS     r6,#0
                  |L1.1914|
;;;668      }
;;;669      /* Select the Opposite Input */
;;;670      if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
00077a  88a0              LDRH     r0,[r4,#4]
00077c  2801              CMP      r0,#1
00077e  d101              BNE      |L1.1924|
;;;671      {
;;;672        icoppositeselection = TIM_ICSelection_IndirectTI;
000780  2702              MOVS     r7,#2
000782  e000              B        |L1.1926|
                  |L1.1924|
;;;673      }
;;;674      else
;;;675      {
;;;676        icoppositeselection = TIM_ICSelection_DirectTI;
000784  2701              MOVS     r7,#1
                  |L1.1926|
;;;677      }
;;;678      if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
000786  8820              LDRH     r0,[r4,#0]
000788  b9a0              CBNZ     r0,|L1.1972|
;;;679      {
;;;680        /* TI1 Configuration */
;;;681        TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
00078a  8923              LDRH     r3,[r4,#8]
00078c  88a2              LDRH     r2,[r4,#4]
00078e  8861              LDRH     r1,[r4,#2]
000790  4628              MOV      r0,r5
000792  f7fffffe          BL       TI1_Config
;;;682                   TIM_ICInitStruct->TIM_ICFilter);
;;;683        /* Set the Input Capture Prescaler value */
;;;684        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000796  88e1              LDRH     r1,[r4,#6]
000798  4628              MOV      r0,r5
00079a  f7fffffe          BL       TIM_SetIC1Prescaler
;;;685        /* TI2 Configuration */
;;;686        TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
00079e  8923              LDRH     r3,[r4,#8]
0007a0  463a              MOV      r2,r7
0007a2  4631              MOV      r1,r6
0007a4  4628              MOV      r0,r5
0007a6  f7fffffe          BL       TI2_Config
;;;687        /* Set the Input Capture Prescaler value */
;;;688        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
0007aa  88e1              LDRH     r1,[r4,#6]
0007ac  4628              MOV      r0,r5
0007ae  f7fffffe          BL       TIM_SetIC2Prescaler
0007b2  e013              B        |L1.2012|
                  |L1.1972|
;;;689      }
;;;690      else
;;;691      { 
;;;692        /* TI2 Configuration */
;;;693        TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
0007b4  8923              LDRH     r3,[r4,#8]
0007b6  88a2              LDRH     r2,[r4,#4]
0007b8  8861              LDRH     r1,[r4,#2]
0007ba  4628              MOV      r0,r5
0007bc  f7fffffe          BL       TI2_Config
;;;694                   TIM_ICInitStruct->TIM_ICFilter);
;;;695        /* Set the Input Capture Prescaler value */
;;;696        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
0007c0  88e1              LDRH     r1,[r4,#6]
0007c2  4628              MOV      r0,r5
0007c4  f7fffffe          BL       TIM_SetIC2Prescaler
;;;697        /* TI1 Configuration */
;;;698        TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
0007c8  8923              LDRH     r3,[r4,#8]
0007ca  463a              MOV      r2,r7
0007cc  4631              MOV      r1,r6
0007ce  4628              MOV      r0,r5
0007d0  f7fffffe          BL       TI1_Config
;;;699        /* Set the Input Capture Prescaler value */
;;;700        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
0007d4  88e1              LDRH     r1,[r4,#6]
0007d6  4628              MOV      r0,r5
0007d8  f7fffffe          BL       TIM_SetIC1Prescaler
                  |L1.2012|
;;;701      }
;;;702    }
0007dc  e8bd81f0          POP      {r4-r8,pc}
;;;703    
                          ENDP

                  TIM_BDTRConfig PROC
;;;711      */
;;;712    void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
0007e0  880a              LDRH     r2,[r1,#0]
;;;713    {
;;;714      /* Check the parameters */
;;;715      assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;716      assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
;;;717      assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
;;;718      assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
;;;719      assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
;;;720      assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
;;;721      assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
;;;722      /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
;;;723         the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;724      TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
0007e2  884b              LDRH     r3,[r1,#2]
0007e4  431a              ORRS     r2,r2,r3
0007e6  888b              LDRH     r3,[r1,#4]
0007e8  431a              ORRS     r2,r2,r3
0007ea  88cb              LDRH     r3,[r1,#6]
0007ec  431a              ORRS     r2,r2,r3
0007ee  890b              LDRH     r3,[r1,#8]
0007f0  431a              ORRS     r2,r2,r3
0007f2  894b              LDRH     r3,[r1,#0xa]
0007f4  431a              ORRS     r2,r2,r3
0007f6  898b              LDRH     r3,[r1,#0xc]
0007f8  431a              ORRS     r2,r2,r3
0007fa  f8a02044          STRH     r2,[r0,#0x44]
;;;725                 TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
;;;726                 TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
;;;727                 TIM_BDTRInitStruct->TIM_AutomaticOutput;
;;;728    }
0007fe  4770              BX       lr
;;;729    
                          ENDP

                  TIM_TimeBaseStructInit PROC
;;;735      */
;;;736    void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000800  f64f71ff          MOV      r1,#0xffff
;;;737    {
;;;738      /* Set the default configuration */
;;;739      TIM_TimeBaseInitStruct->TIM_Period = 0xFFFF;
000804  8081              STRH     r1,[r0,#4]
;;;740      TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
000806  2100              MOVS     r1,#0
000808  8001              STRH     r1,[r0,#0]
;;;741      TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
00080a  80c1              STRH     r1,[r0,#6]
;;;742      TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
00080c  8041              STRH     r1,[r0,#2]
;;;743      TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
00080e  7201              STRB     r1,[r0,#8]
;;;744    }
000810  4770              BX       lr
;;;745    
                          ENDP

                  TIM_OCStructInit PROC
;;;751      */
;;;752    void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
000812  2100              MOVS     r1,#0
;;;753    {
;;;754      /* Set the default configuration */
;;;755      TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
000814  8001              STRH     r1,[r0,#0]
;;;756      TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
000816  8041              STRH     r1,[r0,#2]
;;;757      TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
000818  8081              STRH     r1,[r0,#4]
;;;758      TIM_OCInitStruct->TIM_Pulse = 0x0000;
00081a  80c1              STRH     r1,[r0,#6]
;;;759      TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
00081c  8101              STRH     r1,[r0,#8]
;;;760      TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
00081e  8141              STRH     r1,[r0,#0xa]
;;;761      TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
000820  8181              STRH     r1,[r0,#0xc]
;;;762      TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
000822  81c1              STRH     r1,[r0,#0xe]
;;;763    }
000824  4770              BX       lr
;;;764    
                          ENDP

                  TIM_ICStructInit PROC
;;;770      */
;;;771    void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
000826  2100              MOVS     r1,#0
;;;772    {
;;;773      /* Set the default configuration */
;;;774      TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
000828  8001              STRH     r1,[r0,#0]
;;;775      TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
00082a  8041              STRH     r1,[r0,#2]
;;;776      TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
00082c  2101              MOVS     r1,#1
00082e  8081              STRH     r1,[r0,#4]
;;;777      TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
000830  2100              MOVS     r1,#0
000832  80c1              STRH     r1,[r0,#6]
;;;778      TIM_ICInitStruct->TIM_ICFilter = 0x00;
000834  8101              STRH     r1,[r0,#8]
;;;779    }
000836  4770              BX       lr
;;;780    
                          ENDP

                  TIM_BDTRStructInit PROC
;;;786      */
;;;787    void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
000838  2100              MOVS     r1,#0
;;;788    {
;;;789      /* Set the default configuration */
;;;790      TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
00083a  8001              STRH     r1,[r0,#0]
;;;791      TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
00083c  8041              STRH     r1,[r0,#2]
;;;792      TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
00083e  8081              STRH     r1,[r0,#4]
;;;793      TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
000840  80c1              STRH     r1,[r0,#6]
;;;794      TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
000842  8101              STRH     r1,[r0,#8]
;;;795      TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
000844  8141              STRH     r1,[r0,#0xa]
;;;796      TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
000846  8181              STRH     r1,[r0,#0xc]
;;;797    }
000848  4770              BX       lr
00084a  0000              DCW      0x0000
                  |L1.2124|
                          DCD      0x40012c00
                  |L1.2128|
                          DCD      0x40013400
                  |L1.2132|
                          DCD      0x40000400
                  |L1.2136|
                          DCD      0x40000800
                  |L1.2140|
                          DCD      0x40000c00
                          ENDP

                  TIM_Cmd PROC
;;;805      */
;;;806    void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
000860  b121              CBZ      r1,|L1.2156|
;;;807    {
;;;808      /* Check the parameters */
;;;809      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;810      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;811      
;;;812      if (NewState != DISABLE)
;;;813      {
;;;814        /* Enable the TIM Counter */
;;;815        TIMx->CR1 |= TIM_CR1_CEN;
000862  8802              LDRH     r2,[r0,#0]
000864  f0420201          ORR      r2,r2,#1
000868  8002              STRH     r2,[r0,#0]
00086a  e004              B        |L1.2166|
                  |L1.2156|
;;;816      }
;;;817      else
;;;818      {
;;;819        /* Disable the TIM Counter */
;;;820        TIMx->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN));
00086c  8802              LDRH     r2,[r0,#0]
00086e  f64f73fe          MOV      r3,#0xfffe
000872  401a              ANDS     r2,r2,r3
000874  8002              STRH     r2,[r0,#0]
                  |L1.2166|
;;;821      }
;;;822    }
000876  4770              BX       lr
;;;823    
                          ENDP

                  TIM_CtrlPWMOutputs PROC
;;;830      */
;;;831    void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
000878  b131              CBZ      r1,|L1.2184|
;;;832    {
;;;833      /* Check the parameters */
;;;834      assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;835      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;836      if (NewState != DISABLE)
;;;837      {
;;;838        /* Enable the TIM Main Output */
;;;839        TIMx->BDTR |= TIM_BDTR_MOE;
00087a  f8b02044          LDRH     r2,[r0,#0x44]
00087e  f4424200          ORR      r2,r2,#0x8000
000882  f8a02044          STRH     r2,[r0,#0x44]
000886  e005              B        |L1.2196|
                  |L1.2184|
;;;840      }
;;;841      else
;;;842      {
;;;843        /* Disable the TIM Main Output */
;;;844        TIMx->BDTR &= (uint16_t)(~((uint16_t)TIM_BDTR_MOE));
000888  f8b02044          LDRH     r2,[r0,#0x44]
00088c  f3c2020e          UBFX     r2,r2,#0,#15
000890  f8a02044          STRH     r2,[r0,#0x44]
                  |L1.2196|
;;;845      }  
;;;846    }
000894  4770              BX       lr
;;;847    
                          ENDP

                  TIM_ITConfig PROC
;;;871      */
;;;872    void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
000896  b11a              CBZ      r2,|L1.2208|
;;;873    {  
;;;874      /* Check the parameters */
;;;875      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;876      assert_param(IS_TIM_IT(TIM_IT));
;;;877      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;878      
;;;879      if (NewState != DISABLE)
;;;880      {
;;;881        /* Enable the Interrupt sources */
;;;882        TIMx->DIER |= TIM_IT;
000898  8983              LDRH     r3,[r0,#0xc]
00089a  430b              ORRS     r3,r3,r1
00089c  8183              STRH     r3,[r0,#0xc]
00089e  e002              B        |L1.2214|
                  |L1.2208|
;;;883      }
;;;884      else
;;;885      {
;;;886        /* Disable the Interrupt sources */
;;;887        TIMx->DIER &= (uint16_t)~TIM_IT;
0008a0  8983              LDRH     r3,[r0,#0xc]
0008a2  438b              BICS     r3,r3,r1
0008a4  8183              STRH     r3,[r0,#0xc]
                  |L1.2214|
;;;888      }
;;;889    }
0008a6  4770              BX       lr
;;;890    
                          ENDP

                  TIM_GenerateEvent PROC
;;;908      */
;;;909    void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
0008a8  8281              STRH     r1,[r0,#0x14]
;;;910    { 
;;;911      /* Check the parameters */
;;;912      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;913      assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
;;;914      
;;;915      /* Set the event sources */
;;;916      TIMx->EGR = TIM_EventSource;
;;;917    }
0008aa  4770              BX       lr
;;;918    
                          ENDP

                  TIM_DMAConfig PROC
;;;936      */
;;;937    void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
0008ac  ea410302          ORR      r3,r1,r2
;;;938    {
;;;939      /* Check the parameters */
;;;940      assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;941      assert_param(IS_TIM_DMA_BASE(TIM_DMABase));
;;;942      assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
;;;943      /* Set the DMA Base and the DMA Burst Length */
;;;944      TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
0008b0  f8a03048          STRH     r3,[r0,#0x48]
;;;945    }
0008b4  4770              BX       lr
;;;946    
                          ENDP

                  TIM_DMACmd PROC
;;;963      */
;;;964    void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
0008b6  b11a              CBZ      r2,|L1.2240|
;;;965    { 
;;;966      /* Check the parameters */
;;;967      assert_param(IS_TIM_LIST9_PERIPH(TIMx));
;;;968      assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
;;;969      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;970      
;;;971      if (NewState != DISABLE)
;;;972      {
;;;973        /* Enable the DMA sources */
;;;974        TIMx->DIER |= TIM_DMASource; 
0008b8  8983              LDRH     r3,[r0,#0xc]
0008ba  430b              ORRS     r3,r3,r1
0008bc  8183              STRH     r3,[r0,#0xc]
0008be  e002              B        |L1.2246|
                  |L1.2240|
;;;975      }
;;;976      else
;;;977      {
;;;978        /* Disable the DMA sources */
;;;979        TIMx->DIER &= (uint16_t)~TIM_DMASource;
0008c0  8983              LDRH     r3,[r0,#0xc]
0008c2  438b              BICS     r3,r3,r1
0008c4  8183              STRH     r3,[r0,#0xc]
                  |L1.2246|
;;;980      }
;;;981    }
0008c6  4770              BX       lr
;;;982    
                          ENDP

                  TIM_InternalClockConfig PROC
;;;988      */
;;;989    void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
0008c8  8901              LDRH     r1,[r0,#8]
;;;990    {
;;;991      /* Check the parameters */
;;;992      assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;993      /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;994      TIMx->SMCR &=  (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
0008ca  f64f72f8          MOV      r2,#0xfff8
0008ce  4011              ANDS     r1,r1,r2
0008d0  8101              STRH     r1,[r0,#8]
;;;995    }
0008d2  4770              BX       lr
;;;996    
                          ENDP

                  TIM_SelectInputTrigger PROC
;;;1228     */
;;;1229   void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
0008d4  460a              MOV      r2,r1
;;;1230   {
;;;1231     uint16_t tmpsmcr = 0;
0008d6  2100              MOVS     r1,#0
;;;1232     /* Check the parameters */
;;;1233     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1234     assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;1235     /* Get the TIMx SMCR register value */
;;;1236     tmpsmcr = TIMx->SMCR;
0008d8  8901              LDRH     r1,[r0,#8]
;;;1237     /* Reset the TS Bits */
;;;1238     tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
0008da  f64f738f          MOV      r3,#0xff8f
0008de  4019              ANDS     r1,r1,r3
;;;1239     /* Set the Input Trigger source */
;;;1240     tmpsmcr |= TIM_InputTriggerSource;
0008e0  4311              ORRS     r1,r1,r2
;;;1241     /* Write to TIMx SMCR */
;;;1242     TIMx->SMCR = tmpsmcr;
0008e2  8101              STRH     r1,[r0,#8]
;;;1243   }
0008e4  4770              BX       lr
;;;1244   
                          ENDP

                  TIM_ITRxExternalClockConfig PROC
;;;1007     */
;;;1008   void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
0008e6  b530              PUSH     {r4,r5,lr}
;;;1009   {
0008e8  4604              MOV      r4,r0
0008ea  460d              MOV      r5,r1
;;;1010     /* Check the parameters */
;;;1011     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1012     assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;1013     /* Select the Internal Trigger */
;;;1014     TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
0008ec  4629              MOV      r1,r5
0008ee  4620              MOV      r0,r4
0008f0  f7fffffe          BL       TIM_SelectInputTrigger
;;;1015     /* Select the External clock mode1 */
;;;1016     TIMx->SMCR |= TIM_SlaveMode_External1;
0008f4  8920              LDRH     r0,[r4,#8]
0008f6  f0400007          ORR      r0,r0,#7
0008fa  8120              STRH     r0,[r4,#8]
;;;1017   }
0008fc  bd30              POP      {r4,r5,pc}
;;;1018   
                          ENDP

                  TIM_TIxExternalClockConfig PROC
;;;1034     */
;;;1035   void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
0008fe  e92d41f0          PUSH     {r4-r8,lr}
;;;1036                                   uint16_t TIM_ICPolarity, uint16_t ICFilter)
;;;1037   {
000902  4604              MOV      r4,r0
000904  460d              MOV      r5,r1
000906  4616              MOV      r6,r2
000908  461f              MOV      r7,r3
;;;1038     /* Check the parameters */
;;;1039     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1040     assert_param(IS_TIM_TIXCLK_SOURCE(TIM_TIxExternalCLKSource));
;;;1041     assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
;;;1042     assert_param(IS_TIM_IC_FILTER(ICFilter));
;;;1043     /* Configure the Timer Input Clock Source */
;;;1044     if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
00090a  2d60              CMP      r5,#0x60
00090c  d106              BNE      |L1.2332|
;;;1045     {
;;;1046       TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
00090e  463b              MOV      r3,r7
000910  2201              MOVS     r2,#1
000912  4631              MOV      r1,r6
000914  4620              MOV      r0,r4
000916  f7fffffe          BL       TI2_Config
00091a  e005              B        |L1.2344|
                  |L1.2332|
;;;1047     }
;;;1048     else
;;;1049     {
;;;1050       TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
00091c  463b              MOV      r3,r7
00091e  2201              MOVS     r2,#1
000920  4631              MOV      r1,r6
000922  4620              MOV      r0,r4
000924  f7fffffe          BL       TI1_Config
                  |L1.2344|
;;;1051     }
;;;1052     /* Select the Trigger source */
;;;1053     TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
000928  4629              MOV      r1,r5
00092a  4620              MOV      r0,r4
00092c  f7fffffe          BL       TIM_SelectInputTrigger
;;;1054     /* Select the External clock mode1 */
;;;1055     TIMx->SMCR |= TIM_SlaveMode_External1;
000930  8920              LDRH     r0,[r4,#8]
000932  f0400007          ORR      r0,r0,#7
000936  8120              STRH     r0,[r4,#8]
;;;1056   }
000938  e8bd81f0          POP      {r4-r8,pc}
;;;1057   
                          ENDP

                  TIM_ETRConfig PROC
;;;1147     */
;;;1148   void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
00093c  b530              PUSH     {r4,r5,lr}
;;;1149                      uint16_t ExtTRGFilter)
;;;1150   {
00093e  460c              MOV      r4,r1
;;;1151     uint16_t tmpsmcr = 0;
000940  2100              MOVS     r1,#0
;;;1152     /* Check the parameters */
;;;1153     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1154     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1155     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1156     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1157     tmpsmcr = TIMx->SMCR;
000942  8901              LDRH     r1,[r0,#8]
;;;1158     /* Reset the ETR Bits */
;;;1159     tmpsmcr &= SMCR_ETR_Mask;
000944  b2c9              UXTB     r1,r1
;;;1160     /* Set the Prescaler, the Filter value and the Polarity */
;;;1161     tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
000946  f64f75ff          MOV      r5,#0xffff
00094a  ea052503          AND      r5,r5,r3,LSL #8
00094e  4315              ORRS     r5,r5,r2
000950  4325              ORRS     r5,r5,r4
000952  4329              ORRS     r1,r1,r5
;;;1162     /* Write to TIMx SMCR */
;;;1163     TIMx->SMCR = tmpsmcr;
000954  8101              STRH     r1,[r0,#8]
;;;1164   }
000956  bd30              POP      {r4,r5,pc}
;;;1165   
                          ENDP

                  TIM_ETRClockMode1Config PROC
;;;1074     */
;;;1075   void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
000958  e92d41f0          PUSH     {r4-r8,lr}
;;;1076                                uint16_t ExtTRGFilter)
;;;1077   {
00095c  4605              MOV      r5,r0
00095e  460e              MOV      r6,r1
000960  4617              MOV      r7,r2
000962  4698              MOV      r8,r3
;;;1078     uint16_t tmpsmcr = 0;
000964  2400              MOVS     r4,#0
;;;1079     /* Check the parameters */
;;;1080     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1081     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1082     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1083     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1084     /* Configure the ETR Clock source */
;;;1085     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
000966  4643              MOV      r3,r8
000968  463a              MOV      r2,r7
00096a  4631              MOV      r1,r6
00096c  4628              MOV      r0,r5
00096e  f7fffffe          BL       TIM_ETRConfig
;;;1086     
;;;1087     /* Get the TIMx SMCR register value */
;;;1088     tmpsmcr = TIMx->SMCR;
000972  892c              LDRH     r4,[r5,#8]
;;;1089     /* Reset the SMS Bits */
;;;1090     tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
000974  f64f70f8          MOV      r0,#0xfff8
000978  4004              ANDS     r4,r4,r0
;;;1091     /* Select the External clock mode1 */
;;;1092     tmpsmcr |= TIM_SlaveMode_External1;
00097a  f0440407          ORR      r4,r4,#7
;;;1093     /* Select the Trigger selection : ETRF */
;;;1094     tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
00097e  f64f708f          MOV      r0,#0xff8f
000982  4004              ANDS     r4,r4,r0
;;;1095     tmpsmcr |= TIM_TS_ETRF;
000984  f0440470          ORR      r4,r4,#0x70
;;;1096     /* Write to TIMx SMCR */
;;;1097     TIMx->SMCR = tmpsmcr;
000988  812c              STRH     r4,[r5,#8]
;;;1098   }
00098a  e8bd81f0          POP      {r4-r8,pc}
;;;1099   
                          ENDP

                  TIM_ETRClockMode2Config PROC
;;;1116     */
;;;1117   void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
00098e  b5f0              PUSH     {r4-r7,lr}
;;;1118                                uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;1119   {
000990  4604              MOV      r4,r0
000992  460d              MOV      r5,r1
000994  4616              MOV      r6,r2
000996  461f              MOV      r7,r3
;;;1120     /* Check the parameters */
;;;1121     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1122     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1123     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1124     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1125     /* Configure the ETR Clock source */
;;;1126     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
000998  463b              MOV      r3,r7
00099a  4632              MOV      r2,r6
00099c  4629              MOV      r1,r5
00099e  4620              MOV      r0,r4
0009a0  f7fffffe          BL       TIM_ETRConfig
;;;1127     /* Enable the External clock mode2 */
;;;1128     TIMx->SMCR |= TIM_SMCR_ECE;
0009a4  8920              LDRH     r0,[r4,#8]
0009a6  f4404080          ORR      r0,r0,#0x4000
0009aa  8120              STRH     r0,[r4,#8]
;;;1129   }
0009ac  bdf0              POP      {r4-r7,pc}
;;;1130   
                          ENDP

                  TIM_PrescalerConfig PROC
;;;1175     */
;;;1176   void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
0009ae  8501              STRH     r1,[r0,#0x28]
;;;1177   {
;;;1178     /* Check the parameters */
;;;1179     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;1180     assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
;;;1181     /* Set the Prescaler value */
;;;1182     TIMx->PSC = Prescaler;
;;;1183     /* Set or reset the UG Bit */
;;;1184     TIMx->EGR = TIM_PSCReloadMode;
0009b0  8282              STRH     r2,[r0,#0x14]
;;;1185   }
0009b2  4770              BX       lr
;;;1186   
                          ENDP

                  TIM_CounterModeConfig PROC
;;;1198     */
;;;1199   void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
0009b4  460a              MOV      r2,r1
;;;1200   {
;;;1201     uint16_t tmpcr1 = 0;
0009b6  2100              MOVS     r1,#0
;;;1202     /* Check the parameters */
;;;1203     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1204     assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
;;;1205     tmpcr1 = TIMx->CR1;
0009b8  8801              LDRH     r1,[r0,#0]
;;;1206     /* Reset the CMS and DIR Bits */
;;;1207     tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
0009ba  f64f738f          MOV      r3,#0xff8f
0009be  4019              ANDS     r1,r1,r3
;;;1208     /* Set the Counter Mode */
;;;1209     tmpcr1 |= TIM_CounterMode;
0009c0  4311              ORRS     r1,r1,r2
;;;1210     /* Write to TIMx CR1 register */
;;;1211     TIMx->CR1 = tmpcr1;
0009c2  8001              STRH     r1,[r0,#0]
;;;1212   }
0009c4  4770              BX       lr
;;;1213   
                          ENDP

                  TIM_EncoderInterfaceConfig PROC
;;;1263     */
;;;1264   void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
0009c6  b5f0              PUSH     {r4-r7,lr}
;;;1265                                   uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
;;;1266   {
0009c8  460c              MOV      r4,r1
0009ca  4615              MOV      r5,r2
0009cc  461e              MOV      r6,r3
;;;1267     uint16_t tmpsmcr = 0;
0009ce  2100              MOVS     r1,#0
;;;1268     uint16_t tmpccmr1 = 0;
0009d0  2200              MOVS     r2,#0
;;;1269     uint16_t tmpccer = 0;
0009d2  2300              MOVS     r3,#0
;;;1270       
;;;1271     /* Check the parameters */
;;;1272     assert_param(IS_TIM_LIST5_PERIPH(TIMx));
;;;1273     assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
;;;1274     assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
;;;1275     assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
;;;1276   
;;;1277     /* Get the TIMx SMCR register value */
;;;1278     tmpsmcr = TIMx->SMCR;
0009d4  8901              LDRH     r1,[r0,#8]
;;;1279     
;;;1280     /* Get the TIMx CCMR1 register value */
;;;1281     tmpccmr1 = TIMx->CCMR1;
0009d6  8b02              LDRH     r2,[r0,#0x18]
;;;1282     
;;;1283     /* Get the TIMx CCER register value */
;;;1284     tmpccer = TIMx->CCER;
0009d8  8c03              LDRH     r3,[r0,#0x20]
;;;1285     
;;;1286     /* Set the encoder Mode */
;;;1287     tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
0009da  f64f77f8          MOV      r7,#0xfff8
0009de  4039              ANDS     r1,r1,r7
;;;1288     tmpsmcr |= TIM_EncoderMode;
0009e0  4321              ORRS     r1,r1,r4
;;;1289     
;;;1290     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;1291     tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S)));
0009e2  f64f47fc          MOV      r7,#0xfcfc
0009e6  403a              ANDS     r2,r2,r7
;;;1292     tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
0009e8  f2401701          MOV      r7,#0x101
0009ec  433a              ORRS     r2,r2,r7
;;;1293     
;;;1294     /* Set the TI1 and the TI2 Polarities */
;;;1295     tmpccer &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCER_CC1P)) & ((uint16_t)~((uint16_t)TIM_CCER_CC2P)));
0009ee  f64f77dd          MOV      r7,#0xffdd
0009f2  403b              ANDS     r3,r3,r7
;;;1296     tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
0009f4  f64f77ff          MOV      r7,#0xffff
0009f8  ea071706          AND      r7,r7,r6,LSL #4
0009fc  432f              ORRS     r7,r7,r5
0009fe  433b              ORRS     r3,r3,r7
;;;1297     
;;;1298     /* Write to TIMx SMCR */
;;;1299     TIMx->SMCR = tmpsmcr;
000a00  8101              STRH     r1,[r0,#8]
;;;1300     /* Write to TIMx CCMR1 */
;;;1301     TIMx->CCMR1 = tmpccmr1;
000a02  8302              STRH     r2,[r0,#0x18]
;;;1302     /* Write to TIMx CCER */
;;;1303     TIMx->CCER = tmpccer;
000a04  8403              STRH     r3,[r0,#0x20]
;;;1304   }
000a06  bdf0              POP      {r4-r7,pc}
;;;1305   
                          ENDP

                  TIM_ForcedOC1Config PROC
;;;1314     */
;;;1315   void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000a08  460a              MOV      r2,r1
;;;1316   {
;;;1317     uint16_t tmpccmr1 = 0;
000a0a  2100              MOVS     r1,#0
;;;1318     /* Check the parameters */
;;;1319     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;1320     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1321     tmpccmr1 = TIMx->CCMR1;
000a0c  8b01              LDRH     r1,[r0,#0x18]
;;;1322     /* Reset the OC1M Bits */
;;;1323     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1M);
000a0e  f64f738f          MOV      r3,#0xff8f
000a12  4019              ANDS     r1,r1,r3
;;;1324     /* Configure The Forced output Mode */
;;;1325     tmpccmr1 |= TIM_ForcedAction;
000a14  4311              ORRS     r1,r1,r2
;;;1326     /* Write to TIMx CCMR1 register */
;;;1327     TIMx->CCMR1 = tmpccmr1;
000a16  8301              STRH     r1,[r0,#0x18]
;;;1328   }
000a18  4770              BX       lr
;;;1329   
                          ENDP

                  TIM_ForcedOC2Config PROC
;;;1338     */
;;;1339   void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000a1a  460a              MOV      r2,r1
;;;1340   {
;;;1341     uint16_t tmpccmr1 = 0;
000a1c  2100              MOVS     r1,#0
;;;1342     /* Check the parameters */
;;;1343     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1344     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1345     tmpccmr1 = TIMx->CCMR1;
000a1e  8b01              LDRH     r1,[r0,#0x18]
;;;1346     /* Reset the OC2M Bits */
;;;1347     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2M);
000a20  f64873ff          MOV      r3,#0x8fff
000a24  4019              ANDS     r1,r1,r3
;;;1348     /* Configure The Forced output Mode */
;;;1349     tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
000a26  f64f73ff          MOV      r3,#0xffff
000a2a  ea032302          AND      r3,r3,r2,LSL #8
000a2e  4319              ORRS     r1,r1,r3
;;;1350     /* Write to TIMx CCMR1 register */
;;;1351     TIMx->CCMR1 = tmpccmr1;
000a30  8301              STRH     r1,[r0,#0x18]
;;;1352   }
000a32  4770              BX       lr
;;;1353   
                          ENDP

                  TIM_ForcedOC3Config PROC
;;;1362     */
;;;1363   void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000a34  460a              MOV      r2,r1
;;;1364   {
;;;1365     uint16_t tmpccmr2 = 0;
000a36  2100              MOVS     r1,#0
;;;1366     /* Check the parameters */
;;;1367     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1368     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1369     tmpccmr2 = TIMx->CCMR2;
000a38  8b81              LDRH     r1,[r0,#0x1c]
;;;1370     /* Reset the OC1M Bits */
;;;1371     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3M);
000a3a  f64f738f          MOV      r3,#0xff8f
000a3e  4019              ANDS     r1,r1,r3
;;;1372     /* Configure The Forced output Mode */
;;;1373     tmpccmr2 |= TIM_ForcedAction;
000a40  4311              ORRS     r1,r1,r2
;;;1374     /* Write to TIMx CCMR2 register */
;;;1375     TIMx->CCMR2 = tmpccmr2;
000a42  8381              STRH     r1,[r0,#0x1c]
;;;1376   }
000a44  4770              BX       lr
;;;1377   
                          ENDP

                  TIM_ForcedOC4Config PROC
;;;1386     */
;;;1387   void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000a46  460a              MOV      r2,r1
;;;1388   {
;;;1389     uint16_t tmpccmr2 = 0;
000a48  2100              MOVS     r1,#0
;;;1390     /* Check the parameters */
;;;1391     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1392     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1393     tmpccmr2 = TIMx->CCMR2;
000a4a  8b81              LDRH     r1,[r0,#0x1c]
;;;1394     /* Reset the OC2M Bits */
;;;1395     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4M);
000a4c  f64873ff          MOV      r3,#0x8fff
000a50  4019              ANDS     r1,r1,r3
;;;1396     /* Configure The Forced output Mode */
;;;1397     tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
000a52  f64f73ff          MOV      r3,#0xffff
000a56  ea032302          AND      r3,r3,r2,LSL #8
000a5a  4319              ORRS     r1,r1,r3
;;;1398     /* Write to TIMx CCMR2 register */
;;;1399     TIMx->CCMR2 = tmpccmr2;
000a5c  8381              STRH     r1,[r0,#0x1c]
;;;1400   }
000a5e  4770              BX       lr
;;;1401   
                          ENDP

                  TIM_ARRPreloadConfig PROC
;;;1408     */
;;;1409   void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000a60  b121              CBZ      r1,|L1.2668|
;;;1410   {
;;;1411     /* Check the parameters */
;;;1412     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;1413     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1414     if (NewState != DISABLE)
;;;1415     {
;;;1416       /* Set the ARR Preload Bit */
;;;1417       TIMx->CR1 |= TIM_CR1_ARPE;
000a62  8802              LDRH     r2,[r0,#0]
000a64  f0420280          ORR      r2,r2,#0x80
000a68  8002              STRH     r2,[r0,#0]
000a6a  e004              B        |L1.2678|
                  |L1.2668|
;;;1418     }
;;;1419     else
;;;1420     {
;;;1421       /* Reset the ARR Preload Bit */
;;;1422       TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_ARPE);
000a6c  8802              LDRH     r2,[r0,#0]
000a6e  f64f737f          MOV      r3,#0xff7f
000a72  401a              ANDS     r2,r2,r3
000a74  8002              STRH     r2,[r0,#0]
                  |L1.2678|
;;;1423     }
;;;1424   }
000a76  4770              BX       lr
;;;1425   
                          ENDP

                  TIM_SelectCOM PROC
;;;1432     */
;;;1433   void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
000a78  b121              CBZ      r1,|L1.2692|
;;;1434   {
;;;1435     /* Check the parameters */
;;;1436     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1437     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1438     if (NewState != DISABLE)
;;;1439     {
;;;1440       /* Set the COM Bit */
;;;1441       TIMx->CR2 |= TIM_CR2_CCUS;
000a7a  8882              LDRH     r2,[r0,#4]
000a7c  f0420204          ORR      r2,r2,#4
000a80  8082              STRH     r2,[r0,#4]
000a82  e004              B        |L1.2702|
                  |L1.2692|
;;;1442     }
;;;1443     else
;;;1444     {
;;;1445       /* Reset the COM Bit */
;;;1446       TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCUS);
000a84  8882              LDRH     r2,[r0,#4]
000a86  f64f73fb          MOV      r3,#0xfffb
000a8a  401a              ANDS     r2,r2,r3
000a8c  8082              STRH     r2,[r0,#4]
                  |L1.2702|
;;;1447     }
;;;1448   }
000a8e  4770              BX       lr
;;;1449   
                          ENDP

                  TIM_SelectCCDMA PROC
;;;1457     */
;;;1458   void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
000a90  b121              CBZ      r1,|L1.2716|
;;;1459   {
;;;1460     /* Check the parameters */
;;;1461     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1462     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1463     if (NewState != DISABLE)
;;;1464     {
;;;1465       /* Set the CCDS Bit */
;;;1466       TIMx->CR2 |= TIM_CR2_CCDS;
000a92  8882              LDRH     r2,[r0,#4]
000a94  f0420208          ORR      r2,r2,#8
000a98  8082              STRH     r2,[r0,#4]
000a9a  e004              B        |L1.2726|
                  |L1.2716|
;;;1467     }
;;;1468     else
;;;1469     {
;;;1470       /* Reset the CCDS Bit */
;;;1471       TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCDS);
000a9c  8882              LDRH     r2,[r0,#4]
000a9e  f64f73f7          MOV      r3,#0xfff7
000aa2  401a              ANDS     r2,r2,r3
000aa4  8082              STRH     r2,[r0,#4]
                  |L1.2726|
;;;1472     }
;;;1473   }
000aa6  4770              BX       lr
;;;1474   
                          ENDP

                  TIM_CCPreloadControl PROC
;;;1482     */
;;;1483   void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
000aa8  b121              CBZ      r1,|L1.2740|
;;;1484   { 
;;;1485     /* Check the parameters */
;;;1486     assert_param(IS_TIM_LIST5_PERIPH(TIMx));
;;;1487     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1488     if (NewState != DISABLE)
;;;1489     {
;;;1490       /* Set the CCPC Bit */
;;;1491       TIMx->CR2 |= TIM_CR2_CCPC;
000aaa  8882              LDRH     r2,[r0,#4]
000aac  f0420201          ORR      r2,r2,#1
000ab0  8082              STRH     r2,[r0,#4]
000ab2  e004              B        |L1.2750|
                  |L1.2740|
;;;1492     }
;;;1493     else
;;;1494     {
;;;1495       /* Reset the CCPC Bit */
;;;1496       TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCPC);
000ab4  8882              LDRH     r2,[r0,#4]
000ab6  f64f73fe          MOV      r3,#0xfffe
000aba  401a              ANDS     r2,r2,r3
000abc  8082              STRH     r2,[r0,#4]
                  |L1.2750|
;;;1497     }
;;;1498   }
000abe  4770              BX       lr
;;;1499   
                          ENDP

                  TIM_OC1PreloadConfig PROC
;;;1508     */
;;;1509   void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000ac0  460a              MOV      r2,r1
;;;1510   {
;;;1511     uint16_t tmpccmr1 = 0;
000ac2  2100              MOVS     r1,#0
;;;1512     /* Check the parameters */
;;;1513     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;1514     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1515     tmpccmr1 = TIMx->CCMR1;
000ac4  8b01              LDRH     r1,[r0,#0x18]
;;;1516     /* Reset the OC1PE Bit */
;;;1517     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1PE);
000ac6  f64f73f7          MOV      r3,#0xfff7
000aca  4019              ANDS     r1,r1,r3
;;;1518     /* Enable or Disable the Output Compare Preload feature */
;;;1519     tmpccmr1 |= TIM_OCPreload;
000acc  4311              ORRS     r1,r1,r2
;;;1520     /* Write to TIMx CCMR1 register */
;;;1521     TIMx->CCMR1 = tmpccmr1;
000ace  8301              STRH     r1,[r0,#0x18]
;;;1522   }
000ad0  4770              BX       lr
;;;1523   
                          ENDP

                  TIM_OC2PreloadConfig PROC
;;;1533     */
;;;1534   void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000ad2  460a              MOV      r2,r1
;;;1535   {
;;;1536     uint16_t tmpccmr1 = 0;
000ad4  2100              MOVS     r1,#0
;;;1537     /* Check the parameters */
;;;1538     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1539     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1540     tmpccmr1 = TIMx->CCMR1;
000ad6  8b01              LDRH     r1,[r0,#0x18]
;;;1541     /* Reset the OC2PE Bit */
;;;1542     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2PE);
000ad8  f24f73ff          MOV      r3,#0xf7ff
000adc  4019              ANDS     r1,r1,r3
;;;1543     /* Enable or Disable the Output Compare Preload feature */
;;;1544     tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
000ade  f64f73ff          MOV      r3,#0xffff
000ae2  ea032302          AND      r3,r3,r2,LSL #8
000ae6  4319              ORRS     r1,r1,r3
;;;1545     /* Write to TIMx CCMR1 register */
;;;1546     TIMx->CCMR1 = tmpccmr1;
000ae8  8301              STRH     r1,[r0,#0x18]
;;;1547   }
000aea  4770              BX       lr
;;;1548   
                          ENDP

                  TIM_OC3PreloadConfig PROC
;;;1557     */
;;;1558   void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000aec  460a              MOV      r2,r1
;;;1559   {
;;;1560     uint16_t tmpccmr2 = 0;
000aee  2100              MOVS     r1,#0
;;;1561     /* Check the parameters */
;;;1562     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1563     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1564     tmpccmr2 = TIMx->CCMR2;
000af0  8b81              LDRH     r1,[r0,#0x1c]
;;;1565     /* Reset the OC3PE Bit */
;;;1566     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3PE);
000af2  f64f73f7          MOV      r3,#0xfff7
000af6  4019              ANDS     r1,r1,r3
;;;1567     /* Enable or Disable the Output Compare Preload feature */
;;;1568     tmpccmr2 |= TIM_OCPreload;
000af8  4311              ORRS     r1,r1,r2
;;;1569     /* Write to TIMx CCMR2 register */
;;;1570     TIMx->CCMR2 = tmpccmr2;
000afa  8381              STRH     r1,[r0,#0x1c]
;;;1571   }
000afc  4770              BX       lr
;;;1572   
                          ENDP

                  TIM_OC4PreloadConfig PROC
;;;1581     */
;;;1582   void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000afe  460a              MOV      r2,r1
;;;1583   {
;;;1584     uint16_t tmpccmr2 = 0;
000b00  2100              MOVS     r1,#0
;;;1585     /* Check the parameters */
;;;1586     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1587     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1588     tmpccmr2 = TIMx->CCMR2;
000b02  8b81              LDRH     r1,[r0,#0x1c]
;;;1589     /* Reset the OC4PE Bit */
;;;1590     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4PE);
000b04  f24f73ff          MOV      r3,#0xf7ff
000b08  4019              ANDS     r1,r1,r3
;;;1591     /* Enable or Disable the Output Compare Preload feature */
;;;1592     tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
000b0a  f64f73ff          MOV      r3,#0xffff
000b0e  ea032302          AND      r3,r3,r2,LSL #8
000b12  4319              ORRS     r1,r1,r3
;;;1593     /* Write to TIMx CCMR2 register */
;;;1594     TIMx->CCMR2 = tmpccmr2;
000b14  8381              STRH     r1,[r0,#0x1c]
;;;1595   }
000b16  4770              BX       lr
;;;1596   
                          ENDP

                  TIM_OC1FastConfig PROC
;;;1605     */
;;;1606   void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000b18  460a              MOV      r2,r1
;;;1607   {
;;;1608     uint16_t tmpccmr1 = 0;
000b1a  2100              MOVS     r1,#0
;;;1609     /* Check the parameters */
;;;1610     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;1611     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1612     /* Get the TIMx CCMR1 register value */
;;;1613     tmpccmr1 = TIMx->CCMR1;
000b1c  8b01              LDRH     r1,[r0,#0x18]
;;;1614     /* Reset the OC1FE Bit */
;;;1615     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1FE);
000b1e  f64f73fb          MOV      r3,#0xfffb
000b22  4019              ANDS     r1,r1,r3
;;;1616     /* Enable or Disable the Output Compare Fast Bit */
;;;1617     tmpccmr1 |= TIM_OCFast;
000b24  4311              ORRS     r1,r1,r2
;;;1618     /* Write to TIMx CCMR1 */
;;;1619     TIMx->CCMR1 = tmpccmr1;
000b26  8301              STRH     r1,[r0,#0x18]
;;;1620   }
000b28  4770              BX       lr
;;;1621   
                          ENDP

                  TIM_OC2FastConfig PROC
;;;1631     */
;;;1632   void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000b2a  460a              MOV      r2,r1
;;;1633   {
;;;1634     uint16_t tmpccmr1 = 0;
000b2c  2100              MOVS     r1,#0
;;;1635     /* Check the parameters */
;;;1636     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1637     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1638     /* Get the TIMx CCMR1 register value */
;;;1639     tmpccmr1 = TIMx->CCMR1;
000b2e  8b01              LDRH     r1,[r0,#0x18]
;;;1640     /* Reset the OC2FE Bit */
;;;1641     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2FE);
000b30  f64f33ff          MOV      r3,#0xfbff
000b34  4019              ANDS     r1,r1,r3
;;;1642     /* Enable or Disable the Output Compare Fast Bit */
;;;1643     tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
000b36  f64f73ff          MOV      r3,#0xffff
000b3a  ea032302          AND      r3,r3,r2,LSL #8
000b3e  4319              ORRS     r1,r1,r3
;;;1644     /* Write to TIMx CCMR1 */
;;;1645     TIMx->CCMR1 = tmpccmr1;
000b40  8301              STRH     r1,[r0,#0x18]
;;;1646   }
000b42  4770              BX       lr
;;;1647   
                          ENDP

                  TIM_OC3FastConfig PROC
;;;1656     */
;;;1657   void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000b44  460a              MOV      r2,r1
;;;1658   {
;;;1659     uint16_t tmpccmr2 = 0;
000b46  2100              MOVS     r1,#0
;;;1660     /* Check the parameters */
;;;1661     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1662     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1663     /* Get the TIMx CCMR2 register value */
;;;1664     tmpccmr2 = TIMx->CCMR2;
000b48  8b81              LDRH     r1,[r0,#0x1c]
;;;1665     /* Reset the OC3FE Bit */
;;;1666     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3FE);
000b4a  f64f73fb          MOV      r3,#0xfffb
000b4e  4019              ANDS     r1,r1,r3
;;;1667     /* Enable or Disable the Output Compare Fast Bit */
;;;1668     tmpccmr2 |= TIM_OCFast;
000b50  4311              ORRS     r1,r1,r2
;;;1669     /* Write to TIMx CCMR2 */
;;;1670     TIMx->CCMR2 = tmpccmr2;
000b52  8381              STRH     r1,[r0,#0x1c]
;;;1671   }
000b54  4770              BX       lr
;;;1672   
                          ENDP

                  TIM_OC4FastConfig PROC
;;;1681     */
;;;1682   void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000b56  460a              MOV      r2,r1
;;;1683   {
;;;1684     uint16_t tmpccmr2 = 0;
000b58  2100              MOVS     r1,#0
;;;1685     /* Check the parameters */
;;;1686     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1687     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1688     /* Get the TIMx CCMR2 register value */
;;;1689     tmpccmr2 = TIMx->CCMR2;
000b5a  8b81              LDRH     r1,[r0,#0x1c]
;;;1690     /* Reset the OC4FE Bit */
;;;1691     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4FE);
000b5c  f64f33ff          MOV      r3,#0xfbff
000b60  4019              ANDS     r1,r1,r3
;;;1692     /* Enable or Disable the Output Compare Fast Bit */
;;;1693     tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
000b62  f64f73ff          MOV      r3,#0xffff
000b66  ea032302          AND      r3,r3,r2,LSL #8
000b6a  4319              ORRS     r1,r1,r3
;;;1694     /* Write to TIMx CCMR2 */
;;;1695     TIMx->CCMR2 = tmpccmr2;
000b6c  8381              STRH     r1,[r0,#0x1c]
;;;1696   }
000b6e  4770              BX       lr
;;;1697   
                          ENDP

                  TIM_ClearOC1Ref PROC
;;;1706     */
;;;1707   void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000b70  460a              MOV      r2,r1
;;;1708   {
;;;1709     uint16_t tmpccmr1 = 0;
000b72  2100              MOVS     r1,#0
;;;1710     /* Check the parameters */
;;;1711     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1712     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1713   
;;;1714     tmpccmr1 = TIMx->CCMR1;
000b74  8b01              LDRH     r1,[r0,#0x18]
;;;1715   
;;;1716     /* Reset the OC1CE Bit */
;;;1717     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1CE);
000b76  f64f737f          MOV      r3,#0xff7f
000b7a  4019              ANDS     r1,r1,r3
;;;1718     /* Enable or Disable the Output Compare Clear Bit */
;;;1719     tmpccmr1 |= TIM_OCClear;
000b7c  4311              ORRS     r1,r1,r2
;;;1720     /* Write to TIMx CCMR1 register */
;;;1721     TIMx->CCMR1 = tmpccmr1;
000b7e  8301              STRH     r1,[r0,#0x18]
;;;1722   }
000b80  4770              BX       lr
;;;1723   
                          ENDP

                  TIM_ClearOC2Ref PROC
;;;1732     */
;;;1733   void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000b82  460a              MOV      r2,r1
;;;1734   {
;;;1735     uint16_t tmpccmr1 = 0;
000b84  2100              MOVS     r1,#0
;;;1736     /* Check the parameters */
;;;1737     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1738     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1739     tmpccmr1 = TIMx->CCMR1;
000b86  8b01              LDRH     r1,[r0,#0x18]
;;;1740     /* Reset the OC2CE Bit */
;;;1741     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2CE);
000b88  f3c1010e          UBFX     r1,r1,#0,#15
;;;1742     /* Enable or Disable the Output Compare Clear Bit */
;;;1743     tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
000b8c  f64f73ff          MOV      r3,#0xffff
000b90  ea032302          AND      r3,r3,r2,LSL #8
000b94  4319              ORRS     r1,r1,r3
;;;1744     /* Write to TIMx CCMR1 register */
;;;1745     TIMx->CCMR1 = tmpccmr1;
000b96  8301              STRH     r1,[r0,#0x18]
;;;1746   }
000b98  4770              BX       lr
;;;1747   
                          ENDP

                  TIM_ClearOC3Ref PROC
;;;1756     */
;;;1757   void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000b9a  460a              MOV      r2,r1
;;;1758   {
;;;1759     uint16_t tmpccmr2 = 0;
000b9c  2100              MOVS     r1,#0
;;;1760     /* Check the parameters */
;;;1761     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1762     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1763     tmpccmr2 = TIMx->CCMR2;
000b9e  8b81              LDRH     r1,[r0,#0x1c]
;;;1764     /* Reset the OC3CE Bit */
;;;1765     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3CE);
000ba0  f64f737f          MOV      r3,#0xff7f
000ba4  4019              ANDS     r1,r1,r3
;;;1766     /* Enable or Disable the Output Compare Clear Bit */
;;;1767     tmpccmr2 |= TIM_OCClear;
000ba6  4311              ORRS     r1,r1,r2
;;;1768     /* Write to TIMx CCMR2 register */
;;;1769     TIMx->CCMR2 = tmpccmr2;
000ba8  8381              STRH     r1,[r0,#0x1c]
;;;1770   }
000baa  4770              BX       lr
;;;1771   
                          ENDP

                  TIM_ClearOC4Ref PROC
;;;1780     */
;;;1781   void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000bac  460a              MOV      r2,r1
;;;1782   {
;;;1783     uint16_t tmpccmr2 = 0;
000bae  2100              MOVS     r1,#0
;;;1784     /* Check the parameters */
;;;1785     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1786     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1787     tmpccmr2 = TIMx->CCMR2;
000bb0  8b81              LDRH     r1,[r0,#0x1c]
;;;1788     /* Reset the OC4CE Bit */
;;;1789     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4CE);
000bb2  f3c1010e          UBFX     r1,r1,#0,#15
;;;1790     /* Enable or Disable the Output Compare Clear Bit */
;;;1791     tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
000bb6  f64f73ff          MOV      r3,#0xffff
000bba  ea032302          AND      r3,r3,r2,LSL #8
000bbe  4319              ORRS     r1,r1,r3
;;;1792     /* Write to TIMx CCMR2 register */
;;;1793     TIMx->CCMR2 = tmpccmr2;
000bc0  8381              STRH     r1,[r0,#0x1c]
;;;1794   }
000bc2  4770              BX       lr
;;;1795   
                          ENDP

                  TIM_OC1PolarityConfig PROC
;;;1804     */
;;;1805   void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000bc4  460a              MOV      r2,r1
;;;1806   {
;;;1807     uint16_t tmpccer = 0;
000bc6  2100              MOVS     r1,#0
;;;1808     /* Check the parameters */
;;;1809     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;1810     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1811     tmpccer = TIMx->CCER;
000bc8  8c01              LDRH     r1,[r0,#0x20]
;;;1812     /* Set or Reset the CC1P Bit */
;;;1813     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1P);
000bca  f64f73fd          MOV      r3,#0xfffd
000bce  4019              ANDS     r1,r1,r3
;;;1814     tmpccer |= TIM_OCPolarity;
000bd0  4311              ORRS     r1,r1,r2
;;;1815     /* Write to TIMx CCER register */
;;;1816     TIMx->CCER = tmpccer;
000bd2  8401              STRH     r1,[r0,#0x20]
;;;1817   }
000bd4  4770              BX       lr
;;;1818   
                          ENDP

                  TIM_OC1NPolarityConfig PROC
;;;1827     */
;;;1828   void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000bd6  460a              MOV      r2,r1
;;;1829   {
;;;1830     uint16_t tmpccer = 0;
000bd8  2100              MOVS     r1,#0
;;;1831     /* Check the parameters */
;;;1832     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1833     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1834      
;;;1835     tmpccer = TIMx->CCER;
000bda  8c01              LDRH     r1,[r0,#0x20]
;;;1836     /* Set or Reset the CC1NP Bit */
;;;1837     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1NP);
000bdc  f64f73f7          MOV      r3,#0xfff7
000be0  4019              ANDS     r1,r1,r3
;;;1838     tmpccer |= TIM_OCNPolarity;
000be2  4311              ORRS     r1,r1,r2
;;;1839     /* Write to TIMx CCER register */
;;;1840     TIMx->CCER = tmpccer;
000be4  8401              STRH     r1,[r0,#0x20]
;;;1841   }
000be6  4770              BX       lr
;;;1842   
                          ENDP

                  TIM_OC2PolarityConfig PROC
;;;1851     */
;;;1852   void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000be8  460a              MOV      r2,r1
;;;1853   {
;;;1854     uint16_t tmpccer = 0;
000bea  2100              MOVS     r1,#0
;;;1855     /* Check the parameters */
;;;1856     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1857     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1858     tmpccer = TIMx->CCER;
000bec  8c01              LDRH     r1,[r0,#0x20]
;;;1859     /* Set or Reset the CC2P Bit */
;;;1860     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2P);
000bee  f64f73df          MOV      r3,#0xffdf
000bf2  4019              ANDS     r1,r1,r3
;;;1861     tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
000bf4  f64f73ff          MOV      r3,#0xffff
000bf8  ea031302          AND      r3,r3,r2,LSL #4
000bfc  4319              ORRS     r1,r1,r3
;;;1862     /* Write to TIMx CCER register */
;;;1863     TIMx->CCER = tmpccer;
000bfe  8401              STRH     r1,[r0,#0x20]
;;;1864   }
000c00  4770              BX       lr
;;;1865   
                          ENDP

                  TIM_OC2NPolarityConfig PROC
;;;1874     */
;;;1875   void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000c02  460a              MOV      r2,r1
;;;1876   {
;;;1877     uint16_t tmpccer = 0;
000c04  2100              MOVS     r1,#0
;;;1878     /* Check the parameters */
;;;1879     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1880     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1881     
;;;1882     tmpccer = TIMx->CCER;
000c06  8c01              LDRH     r1,[r0,#0x20]
;;;1883     /* Set or Reset the CC2NP Bit */
;;;1884     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2NP);
000c08  f64f737f          MOV      r3,#0xff7f
000c0c  4019              ANDS     r1,r1,r3
;;;1885     tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
000c0e  f64f73ff          MOV      r3,#0xffff
000c12  ea031302          AND      r3,r3,r2,LSL #4
000c16  4319              ORRS     r1,r1,r3
;;;1886     /* Write to TIMx CCER register */
;;;1887     TIMx->CCER = tmpccer;
000c18  8401              STRH     r1,[r0,#0x20]
;;;1888   }
000c1a  4770              BX       lr
;;;1889   
                          ENDP

                  TIM_OC3PolarityConfig PROC
;;;1898     */
;;;1899   void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000c1c  460a              MOV      r2,r1
;;;1900   {
;;;1901     uint16_t tmpccer = 0;
000c1e  2100              MOVS     r1,#0
;;;1902     /* Check the parameters */
;;;1903     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1904     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1905     tmpccer = TIMx->CCER;
000c20  8c01              LDRH     r1,[r0,#0x20]
;;;1906     /* Set or Reset the CC3P Bit */
;;;1907     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3P);
000c22  f64f53ff          MOV      r3,#0xfdff
000c26  4019              ANDS     r1,r1,r3
;;;1908     tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
000c28  f64f73ff          MOV      r3,#0xffff
000c2c  ea032302          AND      r3,r3,r2,LSL #8
000c30  4319              ORRS     r1,r1,r3
;;;1909     /* Write to TIMx CCER register */
;;;1910     TIMx->CCER = tmpccer;
000c32  8401              STRH     r1,[r0,#0x20]
;;;1911   }
000c34  4770              BX       lr
;;;1912   
                          ENDP

                  TIM_OC3NPolarityConfig PROC
;;;1921     */
;;;1922   void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000c36  460a              MOV      r2,r1
;;;1923   {
;;;1924     uint16_t tmpccer = 0;
000c38  2100              MOVS     r1,#0
;;;1925    
;;;1926     /* Check the parameters */
;;;1927     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1928     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1929       
;;;1930     tmpccer = TIMx->CCER;
000c3a  8c01              LDRH     r1,[r0,#0x20]
;;;1931     /* Set or Reset the CC3NP Bit */
;;;1932     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3NP);
000c3c  f24f73ff          MOV      r3,#0xf7ff
000c40  4019              ANDS     r1,r1,r3
;;;1933     tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
000c42  f64f73ff          MOV      r3,#0xffff
000c46  ea032302          AND      r3,r3,r2,LSL #8
000c4a  4319              ORRS     r1,r1,r3
;;;1934     /* Write to TIMx CCER register */
;;;1935     TIMx->CCER = tmpccer;
000c4c  8401              STRH     r1,[r0,#0x20]
;;;1936   }
000c4e  4770              BX       lr
;;;1937   
                          ENDP

                  TIM_OC4PolarityConfig PROC
;;;1946     */
;;;1947   void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000c50  460a              MOV      r2,r1
;;;1948   {
;;;1949     uint16_t tmpccer = 0;
000c52  2100              MOVS     r1,#0
;;;1950     /* Check the parameters */
;;;1951     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1952     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1953     tmpccer = TIMx->CCER;
000c54  8c01              LDRH     r1,[r0,#0x20]
;;;1954     /* Set or Reset the CC4P Bit */
;;;1955     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC4P);
000c56  f64d73ff          MOV      r3,#0xdfff
000c5a  4019              ANDS     r1,r1,r3
;;;1956     tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
000c5c  f64f73ff          MOV      r3,#0xffff
000c60  ea033302          AND      r3,r3,r2,LSL #12
000c64  4319              ORRS     r1,r1,r3
;;;1957     /* Write to TIMx CCER register */
;;;1958     TIMx->CCER = tmpccer;
000c66  8401              STRH     r1,[r0,#0x20]
;;;1959   }
000c68  4770              BX       lr
;;;1960   
                          ENDP

                  TIM_CCxCmd PROC
;;;1973     */
;;;1974   void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
000c6a  b530              PUSH     {r4,r5,lr}
;;;1975   {
;;;1976     uint16_t tmp = 0;
000c6c  2300              MOVS     r3,#0
;;;1977   
;;;1978     /* Check the parameters */
;;;1979     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;1980     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;1981     assert_param(IS_TIM_CCX(TIM_CCx));
;;;1982   
;;;1983     tmp = CCER_CCE_Set << TIM_Channel;
000c6e  2401              MOVS     r4,#1
000c70  408c              LSLS     r4,r4,r1
000c72  b2a3              UXTH     r3,r4
;;;1984   
;;;1985     /* Reset the CCxE Bit */
;;;1986     TIMx->CCER &= (uint16_t)~ tmp;
000c74  8c04              LDRH     r4,[r0,#0x20]
000c76  439c              BICS     r4,r4,r3
000c78  8404              STRH     r4,[r0,#0x20]
;;;1987   
;;;1988     /* Set or reset the CCxE Bit */ 
;;;1989     TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
000c7a  8c04              LDRH     r4,[r0,#0x20]
000c7c  fa02f501          LSL      r5,r2,r1
000c80  b2ad              UXTH     r5,r5
000c82  432c              ORRS     r4,r4,r5
000c84  8404              STRH     r4,[r0,#0x20]
;;;1990   }
000c86  bd30              POP      {r4,r5,pc}
;;;1991   
                          ENDP

                  TIM_CCxNCmd PROC
;;;2003     */
;;;2004   void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
000c88  b530              PUSH     {r4,r5,lr}
;;;2005   {
;;;2006     uint16_t tmp = 0;
000c8a  2300              MOVS     r3,#0
;;;2007   
;;;2008     /* Check the parameters */
;;;2009     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2010     assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
;;;2011     assert_param(IS_TIM_CCXN(TIM_CCxN));
;;;2012   
;;;2013     tmp = CCER_CCNE_Set << TIM_Channel;
000c8c  2404              MOVS     r4,#4
000c8e  408c              LSLS     r4,r4,r1
000c90  b2a3              UXTH     r3,r4
;;;2014   
;;;2015     /* Reset the CCxNE Bit */
;;;2016     TIMx->CCER &= (uint16_t) ~tmp;
000c92  8c04              LDRH     r4,[r0,#0x20]
000c94  439c              BICS     r4,r4,r3
000c96  8404              STRH     r4,[r0,#0x20]
;;;2017   
;;;2018     /* Set or reset the CCxNE Bit */ 
;;;2019     TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
000c98  8c04              LDRH     r4,[r0,#0x20]
000c9a  fa02f501          LSL      r5,r2,r1
000c9e  b2ad              UXTH     r5,r5
000ca0  432c              ORRS     r4,r4,r5
000ca2  8404              STRH     r4,[r0,#0x20]
;;;2020   }
000ca4  bd30              POP      {r4,r5,pc}
;;;2021   
                          ENDP

                  TIM_SelectOCxM PROC
;;;2044     */
;;;2045   void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
000ca6  b570              PUSH     {r4-r6,lr}
;;;2046   {
000ca8  4603              MOV      r3,r0
;;;2047     uint32_t tmp = 0;
000caa  2000              MOVS     r0,#0
;;;2048     uint16_t tmp1 = 0;
000cac  2400              MOVS     r4,#0
;;;2049   
;;;2050     /* Check the parameters */
;;;2051     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;2052     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;2053     assert_param(IS_TIM_OCM(TIM_OCMode));
;;;2054   
;;;2055     tmp = (uint32_t) TIMx;
000cae  4618              MOV      r0,r3
;;;2056     tmp += CCMR_Offset;
000cb0  3018              ADDS     r0,r0,#0x18
;;;2057   
;;;2058     tmp1 = CCER_CCE_Set << (uint16_t)TIM_Channel;
000cb2  2501              MOVS     r5,#1
000cb4  408d              LSLS     r5,r5,r1
000cb6  b2ac              UXTH     r4,r5
;;;2059   
;;;2060     /* Disable the Channel: Reset the CCxE Bit */
;;;2061     TIMx->CCER &= (uint16_t) ~tmp1;
000cb8  8c1d              LDRH     r5,[r3,#0x20]
000cba  43a5              BICS     r5,r5,r4
000cbc  841d              STRH     r5,[r3,#0x20]
;;;2062   
;;;2063     if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
000cbe  b109              CBZ      r1,|L1.3268|
000cc0  2908              CMP      r1,#8
000cc2  d109              BNE      |L1.3288|
                  |L1.3268|
;;;2064     {
;;;2065       tmp += (TIM_Channel>>1);
000cc4  eb000061          ADD      r0,r0,r1,ASR #1
;;;2066   
;;;2067       /* Reset the OCxM bits in the CCMRx register */
;;;2068       *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC1M);
000cc8  6805              LDR      r5,[r0,#0]
000cca  f0250570          BIC      r5,r5,#0x70
000cce  6005              STR      r5,[r0,#0]
;;;2069      
;;;2070       /* Configure the OCxM bits in the CCMRx register */
;;;2071       *(__IO uint32_t *) tmp |= TIM_OCMode;
000cd0  6805              LDR      r5,[r0,#0]
000cd2  4315              ORRS     r5,r5,r2
000cd4  6005              STR      r5,[r0,#0]
000cd6  e00e              B        |L1.3318|
                  |L1.3288|
;;;2072     }
;;;2073     else
;;;2074     {
;;;2075       tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
000cd8  1f0d              SUBS     r5,r1,#4
000cda  f3c5054e          UBFX     r5,r5,#1,#15
000cde  4428              ADD      r0,r0,r5
;;;2076   
;;;2077       /* Reset the OCxM bits in the CCMRx register */
;;;2078       *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC2M);
000ce0  6805              LDR      r5,[r0,#0]
000ce2  f42545e0          BIC      r5,r5,#0x7000
000ce6  6005              STR      r5,[r0,#0]
;;;2079       
;;;2080       /* Configure the OCxM bits in the CCMRx register */
;;;2081       *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
000ce8  6805              LDR      r5,[r0,#0]
000cea  f64f76ff          MOV      r6,#0xffff
000cee  ea062602          AND      r6,r6,r2,LSL #8
000cf2  4335              ORRS     r5,r5,r6
000cf4  6005              STR      r5,[r0,#0]
                  |L1.3318|
;;;2082     }
;;;2083   }
000cf6  bd70              POP      {r4-r6,pc}
;;;2084   
                          ENDP

                  TIM_UpdateDisableConfig PROC
;;;2091     */
;;;2092   void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000cf8  b121              CBZ      r1,|L1.3332|
;;;2093   {
;;;2094     /* Check the parameters */
;;;2095     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2096     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2097     if (NewState != DISABLE)
;;;2098     {
;;;2099       /* Set the Update Disable Bit */
;;;2100       TIMx->CR1 |= TIM_CR1_UDIS;
000cfa  8802              LDRH     r2,[r0,#0]
000cfc  f0420202          ORR      r2,r2,#2
000d00  8002              STRH     r2,[r0,#0]
000d02  e004              B        |L1.3342|
                  |L1.3332|
;;;2101     }
;;;2102     else
;;;2103     {
;;;2104       /* Reset the Update Disable Bit */
;;;2105       TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_UDIS);
000d04  8802              LDRH     r2,[r0,#0]
000d06  f64f73fd          MOV      r3,#0xfffd
000d0a  401a              ANDS     r2,r2,r3
000d0c  8002              STRH     r2,[r0,#0]
                  |L1.3342|
;;;2106     }
;;;2107   }
000d0e  4770              BX       lr
;;;2108   
                          ENDP

                  TIM_UpdateRequestConfig PROC
;;;2119     */
;;;2120   void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
000d10  b121              CBZ      r1,|L1.3356|
;;;2121   {
;;;2122     /* Check the parameters */
;;;2123     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2124     assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
;;;2125     if (TIM_UpdateSource != TIM_UpdateSource_Global)
;;;2126     {
;;;2127       /* Set the URS Bit */
;;;2128       TIMx->CR1 |= TIM_CR1_URS;
000d12  8802              LDRH     r2,[r0,#0]
000d14  f0420204          ORR      r2,r2,#4
000d18  8002              STRH     r2,[r0,#0]
000d1a  e004              B        |L1.3366|
                  |L1.3356|
;;;2129     }
;;;2130     else
;;;2131     {
;;;2132       /* Reset the URS Bit */
;;;2133       TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_URS);
000d1c  8802              LDRH     r2,[r0,#0]
000d1e  f64f73fb          MOV      r3,#0xfffb
000d22  401a              ANDS     r2,r2,r3
000d24  8002              STRH     r2,[r0,#0]
                  |L1.3366|
;;;2134     }
;;;2135   }
000d26  4770              BX       lr
;;;2136   
                          ENDP

                  TIM_SelectHallSensor PROC
;;;2143     */
;;;2144   void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
000d28  b121              CBZ      r1,|L1.3380|
;;;2145   {
;;;2146     /* Check the parameters */
;;;2147     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2148     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2149     if (NewState != DISABLE)
;;;2150     {
;;;2151       /* Set the TI1S Bit */
;;;2152       TIMx->CR2 |= TIM_CR2_TI1S;
000d2a  8882              LDRH     r2,[r0,#4]
000d2c  f0420280          ORR      r2,r2,#0x80
000d30  8082              STRH     r2,[r0,#4]
000d32  e004              B        |L1.3390|
                  |L1.3380|
;;;2153     }
;;;2154     else
;;;2155     {
;;;2156       /* Reset the TI1S Bit */
;;;2157       TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_TI1S);
000d34  8882              LDRH     r2,[r0,#4]
000d36  f64f737f          MOV      r3,#0xff7f
000d3a  401a              ANDS     r2,r2,r3
000d3c  8082              STRH     r2,[r0,#4]
                  |L1.3390|
;;;2158     }
;;;2159   }
000d3e  4770              BX       lr
;;;2160   
                          ENDP

                  TIM_SelectOnePulseMode PROC
;;;2169     */
;;;2170   void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
000d40  8802              LDRH     r2,[r0,#0]
;;;2171   {
;;;2172     /* Check the parameters */
;;;2173     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2174     assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
;;;2175     /* Reset the OPM Bit */
;;;2176     TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_OPM);
000d42  f64f73f7          MOV      r3,#0xfff7
000d46  401a              ANDS     r2,r2,r3
000d48  8002              STRH     r2,[r0,#0]
;;;2177     /* Configure the OPM Mode */
;;;2178     TIMx->CR1 |= TIM_OPMode;
000d4a  8802              LDRH     r2,[r0,#0]
000d4c  430a              ORRS     r2,r2,r1
000d4e  8002              STRH     r2,[r0,#0]
;;;2179   }
000d50  4770              BX       lr
;;;2180   
                          ENDP

                  TIM_SelectOutputTrigger PROC
;;;2201     */
;;;2202   void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
000d52  8882              LDRH     r2,[r0,#4]
;;;2203   {
;;;2204     /* Check the parameters */
;;;2205     assert_param(IS_TIM_LIST7_PERIPH(TIMx));
;;;2206     assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
;;;2207     /* Reset the MMS Bits */
;;;2208     TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_MMS);
000d54  f64f738f          MOV      r3,#0xff8f
000d58  401a              ANDS     r2,r2,r3
000d5a  8082              STRH     r2,[r0,#4]
;;;2209     /* Select the TRGO source */
;;;2210     TIMx->CR2 |=  TIM_TRGOSource;
000d5c  8882              LDRH     r2,[r0,#4]
000d5e  430a              ORRS     r2,r2,r1
000d60  8082              STRH     r2,[r0,#4]
;;;2211   }
000d62  4770              BX       lr
;;;2212   
                          ENDP

                  TIM_SelectSlaveMode PROC
;;;2224     */
;;;2225   void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
000d64  8902              LDRH     r2,[r0,#8]
;;;2226   {
;;;2227     /* Check the parameters */
;;;2228     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2229     assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
;;;2230    /* Reset the SMS Bits */
;;;2231     TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_SMS);
000d66  f64f73f8          MOV      r3,#0xfff8
000d6a  401a              ANDS     r2,r2,r3
000d6c  8102              STRH     r2,[r0,#8]
;;;2232     /* Select the Slave Mode */
;;;2233     TIMx->SMCR |= TIM_SlaveMode;
000d6e  8902              LDRH     r2,[r0,#8]
000d70  430a              ORRS     r2,r2,r1
000d72  8102              STRH     r2,[r0,#8]
;;;2234   }
000d74  4770              BX       lr
;;;2235   
                          ENDP

                  TIM_SelectMasterSlaveMode PROC
;;;2245     */
;;;2246   void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
000d76  8902              LDRH     r2,[r0,#8]
;;;2247   {
;;;2248     /* Check the parameters */
;;;2249     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2250     assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
;;;2251     /* Reset the MSM Bit */
;;;2252     TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_MSM);
000d78  f64f737f          MOV      r3,#0xff7f
000d7c  401a              ANDS     r2,r2,r3
000d7e  8102              STRH     r2,[r0,#8]
;;;2253     
;;;2254     /* Set or Reset the MSM Bit */
;;;2255     TIMx->SMCR |= TIM_MasterSlaveMode;
000d80  8902              LDRH     r2,[r0,#8]
000d82  430a              ORRS     r2,r2,r1
000d84  8102              STRH     r2,[r0,#8]
;;;2256   }
000d86  4770              BX       lr
;;;2257   
                          ENDP

                  TIM_SetCounter PROC
;;;2263     */
;;;2264   void TIM_SetCounter(TIM_TypeDef* TIMx, uint16_t Counter)
000d88  8481              STRH     r1,[r0,#0x24]
;;;2265   {
;;;2266     /* Check the parameters */
;;;2267     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2268     /* Set the Counter Register value */
;;;2269     TIMx->CNT = Counter;
;;;2270   }
000d8a  4770              BX       lr
;;;2271   
                          ENDP

                  TIM_SetAutoreload PROC
;;;2277     */
;;;2278   void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint16_t Autoreload)
000d8c  8581              STRH     r1,[r0,#0x2c]
;;;2279   {
;;;2280     /* Check the parameters */
;;;2281     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2282     /* Set the Autoreload Register value */
;;;2283     TIMx->ARR = Autoreload;
;;;2284   }
000d8e  4770              BX       lr
;;;2285   
                          ENDP

                  TIM_SetCompare1 PROC
;;;2291     */
;;;2292   void TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1)
000d90  8681              STRH     r1,[r0,#0x34]
;;;2293   {
;;;2294     /* Check the parameters */
;;;2295     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;2296     /* Set the Capture Compare1 Register value */
;;;2297     TIMx->CCR1 = Compare1;
;;;2298   }
000d92  4770              BX       lr
;;;2299   
                          ENDP

                  TIM_SetCompare2 PROC
;;;2305     */
;;;2306   void TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2)
000d94  8701              STRH     r1,[r0,#0x38]
;;;2307   {
;;;2308     /* Check the parameters */
;;;2309     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2310     /* Set the Capture Compare2 Register value */
;;;2311     TIMx->CCR2 = Compare2;
;;;2312   }
000d96  4770              BX       lr
;;;2313   
                          ENDP

                  TIM_SetCompare3 PROC
;;;2319     */
;;;2320   void TIM_SetCompare3(TIM_TypeDef* TIMx, uint16_t Compare3)
000d98  8781              STRH     r1,[r0,#0x3c]
;;;2321   {
;;;2322     /* Check the parameters */
;;;2323     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2324     /* Set the Capture Compare3 Register value */
;;;2325     TIMx->CCR3 = Compare3;
;;;2326   }
000d9a  4770              BX       lr
;;;2327   
                          ENDP

                  TIM_SetCompare4 PROC
;;;2333     */
;;;2334   void TIM_SetCompare4(TIM_TypeDef* TIMx, uint16_t Compare4)
000d9c  f8a01040          STRH     r1,[r0,#0x40]
;;;2335   {
;;;2336     /* Check the parameters */
;;;2337     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2338     /* Set the Capture Compare4 Register value */
;;;2339     TIMx->CCR4 = Compare4;
;;;2340   }
000da0  4770              BX       lr
;;;2341   
                          ENDP

                  TIM_SetClockDivision PROC
;;;2440     */
;;;2441   void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
000da2  8802              LDRH     r2,[r0,#0]
;;;2442   {
;;;2443     /* Check the parameters */
;;;2444     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;2445     assert_param(IS_TIM_CKD_DIV(TIM_CKD));
;;;2446     /* Reset the CKD Bits */
;;;2447     TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_CKD);
000da4  f64f43ff          MOV      r3,#0xfcff
000da8  401a              ANDS     r2,r2,r3
000daa  8002              STRH     r2,[r0,#0]
;;;2448     /* Set the CKD value */
;;;2449     TIMx->CR1 |= TIM_CKD;
000dac  8802              LDRH     r2,[r0,#0]
000dae  430a              ORRS     r2,r2,r1
000db0  8002              STRH     r2,[r0,#0]
;;;2450   }
000db2  4770              BX       lr
;;;2451   
                          ENDP

                  TIM_GetCapture1 PROC
;;;2456     */
;;;2457   uint16_t TIM_GetCapture1(TIM_TypeDef* TIMx)
000db4  4601              MOV      r1,r0
;;;2458   {
;;;2459     /* Check the parameters */
;;;2460     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;2461     /* Get the Capture 1 Register value */
;;;2462     return TIMx->CCR1;
000db6  8e88              LDRH     r0,[r1,#0x34]
;;;2463   }
000db8  4770              BX       lr
;;;2464   
                          ENDP

                  TIM_GetCapture2 PROC
;;;2469     */
;;;2470   uint16_t TIM_GetCapture2(TIM_TypeDef* TIMx)
000dba  4601              MOV      r1,r0
;;;2471   {
;;;2472     /* Check the parameters */
;;;2473     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2474     /* Get the Capture 2 Register value */
;;;2475     return TIMx->CCR2;
000dbc  8f08              LDRH     r0,[r1,#0x38]
;;;2476   }
000dbe  4770              BX       lr
;;;2477   
                          ENDP

                  TIM_GetCapture3 PROC
;;;2482     */
;;;2483   uint16_t TIM_GetCapture3(TIM_TypeDef* TIMx)
000dc0  4601              MOV      r1,r0
;;;2484   {
;;;2485     /* Check the parameters */
;;;2486     assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;2487     /* Get the Capture 3 Register value */
;;;2488     return TIMx->CCR3;
000dc2  8f88              LDRH     r0,[r1,#0x3c]
;;;2489   }
000dc4  4770              BX       lr
;;;2490   
                          ENDP

                  TIM_GetCapture4 PROC
;;;2495     */
;;;2496   uint16_t TIM_GetCapture4(TIM_TypeDef* TIMx)
000dc6  4601              MOV      r1,r0
;;;2497   {
;;;2498     /* Check the parameters */
;;;2499     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2500     /* Get the Capture 4 Register value */
;;;2501     return TIMx->CCR4;
000dc8  f8b10040          LDRH     r0,[r1,#0x40]
;;;2502   }
000dcc  4770              BX       lr
;;;2503   
                          ENDP

                  TIM_GetCounter PROC
;;;2508     */
;;;2509   uint16_t TIM_GetCounter(TIM_TypeDef* TIMx)
000dce  4601              MOV      r1,r0
;;;2510   {
;;;2511     /* Check the parameters */
;;;2512     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2513     /* Get the Counter Register value */
;;;2514     return TIMx->CNT;
000dd0  8c88              LDRH     r0,[r1,#0x24]
;;;2515   }
000dd2  4770              BX       lr
;;;2516   
                          ENDP

                  TIM_GetPrescaler PROC
;;;2521     */
;;;2522   uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
000dd4  4601              MOV      r1,r0
;;;2523   {
;;;2524     /* Check the parameters */
;;;2525     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2526     /* Get the Prescaler Register value */
;;;2527     return TIMx->PSC;
000dd6  8d08              LDRH     r0,[r1,#0x28]
;;;2528   }
000dd8  4770              BX       lr
;;;2529   
                          ENDP

                  TIM_GetFlagStatus PROC
;;;2555     */
;;;2556   FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000dda  4602              MOV      r2,r0
;;;2557   { 
;;;2558     ITStatus bitstatus = RESET;  
000ddc  2000              MOVS     r0,#0
;;;2559     /* Check the parameters */
;;;2560     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2561     assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
;;;2562     
;;;2563     if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
000dde  8a13              LDRH     r3,[r2,#0x10]
000de0  420b              TST      r3,r1
000de2  d001              BEQ      |L1.3560|
;;;2564     {
;;;2565       bitstatus = SET;
000de4  2001              MOVS     r0,#1
000de6  e000              B        |L1.3562|
                  |L1.3560|
;;;2566     }
;;;2567     else
;;;2568     {
;;;2569       bitstatus = RESET;
000de8  2000              MOVS     r0,#0
                  |L1.3562|
;;;2570     }
;;;2571     return bitstatus;
;;;2572   }
000dea  4770              BX       lr
;;;2573   
                          ENDP

                  TIM_ClearFlag PROC
;;;2599     */
;;;2600   void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000dec  43ca              MVNS     r2,r1
;;;2601   {  
;;;2602     /* Check the parameters */
;;;2603     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2604     assert_param(IS_TIM_CLEAR_FLAG(TIM_FLAG));
;;;2605      
;;;2606     /* Clear the flags */
;;;2607     TIMx->SR = (uint16_t)~TIM_FLAG;
000dee  8202              STRH     r2,[r0,#0x10]
;;;2608   }
000df0  4770              BX       lr
;;;2609   
                          ENDP

                  TIM_GetITStatus PROC
;;;2631     */
;;;2632   ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000df2  b530              PUSH     {r4,r5,lr}
;;;2633   {
000df4  4602              MOV      r2,r0
;;;2634     ITStatus bitstatus = RESET;  
000df6  2000              MOVS     r0,#0
;;;2635     uint16_t itstatus = 0x0, itenable = 0x0;
000df8  2300              MOVS     r3,#0
000dfa  2400              MOVS     r4,#0
;;;2636     /* Check the parameters */
;;;2637     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2638     assert_param(IS_TIM_GET_IT(TIM_IT));
;;;2639      
;;;2640     itstatus = TIMx->SR & TIM_IT;
000dfc  8a15              LDRH     r5,[r2,#0x10]
000dfe  ea050301          AND      r3,r5,r1
;;;2641     
;;;2642     itenable = TIMx->DIER & TIM_IT;
000e02  8995              LDRH     r5,[r2,#0xc]
000e04  ea050401          AND      r4,r5,r1
;;;2643     if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
000e08  b113              CBZ      r3,|L1.3600|
000e0a  b10c              CBZ      r4,|L1.3600|
;;;2644     {
;;;2645       bitstatus = SET;
000e0c  2001              MOVS     r0,#1
000e0e  e000              B        |L1.3602|
                  |L1.3600|
;;;2646     }
;;;2647     else
;;;2648     {
;;;2649       bitstatus = RESET;
000e10  2000              MOVS     r0,#0
                  |L1.3602|
;;;2650     }
;;;2651     return bitstatus;
;;;2652   }
000e12  bd30              POP      {r4,r5,pc}
;;;2653   
                          ENDP

                  TIM_ClearITPendingBit PROC
;;;2675     */
;;;2676   void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000e14  43ca              MVNS     r2,r1
;;;2677   {
;;;2678     /* Check the parameters */
;;;2679     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2680     assert_param(IS_TIM_IT(TIM_IT));
;;;2681     /* Clear the IT pending Bit */
;;;2682     TIMx->SR = (uint16_t)~TIM_IT;
000e16  8202              STRH     r2,[r0,#0x10]
;;;2683   }
000e18  4770              BX       lr
;;;2684   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_tim.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f10x_tim_c_c458916b____REV16|
#line 129 "E:\\keli\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f10x_tim_c_c458916b____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f10x_tim_c_c458916b____REVSH|
#line 144
|__asm___15_stm32f10x_tim_c_c458916b____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
