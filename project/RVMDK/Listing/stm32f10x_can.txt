; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\output\stm32f10x_can.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\output\stm32f10x_can.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\User -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\bsp_lib -IE:\keli\ARM\RV31\INC -IE:\keli\ARM\CMSIS\Include -IE:\keli\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\stm32f10x_can.crf ..\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_can.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  CAN_DeInit PROC
;;;121      */
;;;122    void CAN_DeInit(CAN_TypeDef* CANx)
000000  b510              PUSH     {r4,lr}
;;;123    {
000002  4604              MOV      r4,r0
;;;124      /* Check the parameters */
;;;125      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;126     
;;;127      if (CANx == CAN1)
000004  48fe              LDR      r0,|L1.1024|
000006  4284              CMP      r4,r0
000008  d109              BNE      |L1.30|
;;;128      {
;;;129        /* Enable CAN1 reset state */
;;;130        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  0648              LSLS     r0,r1,#25
00000e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;131        /* Release CAN1 from reset state */
;;;132        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, DISABLE);
000012  2100              MOVS     r1,#0
000014  f04f7000          MOV      r0,#0x2000000
000018  f7fffffe          BL       RCC_APB1PeriphResetCmd
00001c  e008              B        |L1.48|
                  |L1.30|
;;;133      }
;;;134      else
;;;135      {  
;;;136        /* Enable CAN2 reset state */
;;;137        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, ENABLE);
00001e  2101              MOVS     r1,#1
000020  0688              LSLS     r0,r1,#26
000022  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;138        /* Release CAN2 from reset state */
;;;139        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, DISABLE);
000026  2100              MOVS     r1,#0
000028  f04f6080          MOV      r0,#0x4000000
00002c  f7fffffe          BL       RCC_APB1PeriphResetCmd
                  |L1.48|
;;;140      }
;;;141    }
000030  bd10              POP      {r4,pc}
;;;142    
                          ENDP

                  CAN_Init PROC
;;;153      */
;;;154    uint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct)
000032  b530              PUSH     {r4,r5,lr}
;;;155    {
000034  4602              MOV      r2,r0
;;;156      uint8_t InitStatus = CAN_InitStatus_Failed;
000036  2000              MOVS     r0,#0
;;;157      uint32_t wait_ack = 0x00000000;
000038  2300              MOVS     r3,#0
;;;158      /* Check the parameters */
;;;159      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;160      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TTCM));
;;;161      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ABOM));
;;;162      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_AWUM));
;;;163      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_NART));
;;;164      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_RFLM));
;;;165      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TXFP));
;;;166      assert_param(IS_CAN_MODE(CAN_InitStruct->CAN_Mode));
;;;167      assert_param(IS_CAN_SJW(CAN_InitStruct->CAN_SJW));
;;;168      assert_param(IS_CAN_BS1(CAN_InitStruct->CAN_BS1));
;;;169      assert_param(IS_CAN_BS2(CAN_InitStruct->CAN_BS2));
;;;170      assert_param(IS_CAN_PRESCALER(CAN_InitStruct->CAN_Prescaler));
;;;171    
;;;172      /* Exit from sleep mode */
;;;173      CANx->MCR &= (~(uint32_t)CAN_MCR_SLEEP);
00003a  6814              LDR      r4,[r2,#0]
00003c  f0240402          BIC      r4,r4,#2
000040  6014              STR      r4,[r2,#0]
;;;174    
;;;175      /* Request initialisation */
;;;176      CANx->MCR |= CAN_MCR_INRQ ;
000042  6814              LDR      r4,[r2,#0]
000044  f0440401          ORR      r4,r4,#1
000048  6014              STR      r4,[r2,#0]
;;;177    
;;;178      /* Wait the acknowledge */
;;;179      while (((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
00004a  e000              B        |L1.78|
                  |L1.76|
;;;180      {
;;;181        wait_ack++;
00004c  1c5b              ADDS     r3,r3,#1
                  |L1.78|
00004e  6854              LDR      r4,[r2,#4]            ;179
000050  f0140f01          TST      r4,#1                 ;179
000054  d103              BNE      |L1.94|
000056  f5a3447f          SUB      r4,r3,#0xff00         ;179
00005a  3cff              SUBS     r4,r4,#0xff           ;179
00005c  d1f6              BNE      |L1.76|
                  |L1.94|
;;;182      }
;;;183    
;;;184      /* Check acknowledge */
;;;185      if ((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
00005e  6854              LDR      r4,[r2,#4]
000060  f0140f01          TST      r4,#1
000064  d101              BNE      |L1.106|
;;;186      {
;;;187        InitStatus = CAN_InitStatus_Failed;
000066  2000              MOVS     r0,#0
000068  e06c              B        |L1.324|
                  |L1.106|
;;;188      }
;;;189      else 
;;;190      {
;;;191        /* Set the time triggered communication mode */
;;;192        if (CAN_InitStruct->CAN_TTCM == ENABLE)
00006a  798c              LDRB     r4,[r1,#6]
00006c  2c01              CMP      r4,#1
00006e  d104              BNE      |L1.122|
;;;193        {
;;;194          CANx->MCR |= CAN_MCR_TTCM;
000070  6814              LDR      r4,[r2,#0]
000072  f0440480          ORR      r4,r4,#0x80
000076  6014              STR      r4,[r2,#0]
000078  e003              B        |L1.130|
                  |L1.122|
;;;195        }
;;;196        else
;;;197        {
;;;198          CANx->MCR &= ~(uint32_t)CAN_MCR_TTCM;
00007a  6814              LDR      r4,[r2,#0]
00007c  f0240480          BIC      r4,r4,#0x80
000080  6014              STR      r4,[r2,#0]
                  |L1.130|
;;;199        }
;;;200    
;;;201        /* Set the automatic bus-off management */
;;;202        if (CAN_InitStruct->CAN_ABOM == ENABLE)
000082  79cc              LDRB     r4,[r1,#7]
000084  2c01              CMP      r4,#1
000086  d104              BNE      |L1.146|
;;;203        {
;;;204          CANx->MCR |= CAN_MCR_ABOM;
000088  6814              LDR      r4,[r2,#0]
00008a  f0440440          ORR      r4,r4,#0x40
00008e  6014              STR      r4,[r2,#0]
000090  e003              B        |L1.154|
                  |L1.146|
;;;205        }
;;;206        else
;;;207        {
;;;208          CANx->MCR &= ~(uint32_t)CAN_MCR_ABOM;
000092  6814              LDR      r4,[r2,#0]
000094  f0240440          BIC      r4,r4,#0x40
000098  6014              STR      r4,[r2,#0]
                  |L1.154|
;;;209        }
;;;210    
;;;211        /* Set the automatic wake-up mode */
;;;212        if (CAN_InitStruct->CAN_AWUM == ENABLE)
00009a  7a0c              LDRB     r4,[r1,#8]
00009c  2c01              CMP      r4,#1
00009e  d104              BNE      |L1.170|
;;;213        {
;;;214          CANx->MCR |= CAN_MCR_AWUM;
0000a0  6814              LDR      r4,[r2,#0]
0000a2  f0440420          ORR      r4,r4,#0x20
0000a6  6014              STR      r4,[r2,#0]
0000a8  e003              B        |L1.178|
                  |L1.170|
;;;215        }
;;;216        else
;;;217        {
;;;218          CANx->MCR &= ~(uint32_t)CAN_MCR_AWUM;
0000aa  6814              LDR      r4,[r2,#0]
0000ac  f0240420          BIC      r4,r4,#0x20
0000b0  6014              STR      r4,[r2,#0]
                  |L1.178|
;;;219        }
;;;220    
;;;221        /* Set the no automatic retransmission */
;;;222        if (CAN_InitStruct->CAN_NART == ENABLE)
0000b2  7a4c              LDRB     r4,[r1,#9]
0000b4  2c01              CMP      r4,#1
0000b6  d104              BNE      |L1.194|
;;;223        {
;;;224          CANx->MCR |= CAN_MCR_NART;
0000b8  6814              LDR      r4,[r2,#0]
0000ba  f0440410          ORR      r4,r4,#0x10
0000be  6014              STR      r4,[r2,#0]
0000c0  e003              B        |L1.202|
                  |L1.194|
;;;225        }
;;;226        else
;;;227        {
;;;228          CANx->MCR &= ~(uint32_t)CAN_MCR_NART;
0000c2  6814              LDR      r4,[r2,#0]
0000c4  f0240410          BIC      r4,r4,#0x10
0000c8  6014              STR      r4,[r2,#0]
                  |L1.202|
;;;229        }
;;;230    
;;;231        /* Set the receive FIFO locked mode */
;;;232        if (CAN_InitStruct->CAN_RFLM == ENABLE)
0000ca  7a8c              LDRB     r4,[r1,#0xa]
0000cc  2c01              CMP      r4,#1
0000ce  d104              BNE      |L1.218|
;;;233        {
;;;234          CANx->MCR |= CAN_MCR_RFLM;
0000d0  6814              LDR      r4,[r2,#0]
0000d2  f0440408          ORR      r4,r4,#8
0000d6  6014              STR      r4,[r2,#0]
0000d8  e003              B        |L1.226|
                  |L1.218|
;;;235        }
;;;236        else
;;;237        {
;;;238          CANx->MCR &= ~(uint32_t)CAN_MCR_RFLM;
0000da  6814              LDR      r4,[r2,#0]
0000dc  f0240408          BIC      r4,r4,#8
0000e0  6014              STR      r4,[r2,#0]
                  |L1.226|
;;;239        }
;;;240    
;;;241        /* Set the transmit FIFO priority */
;;;242        if (CAN_InitStruct->CAN_TXFP == ENABLE)
0000e2  7acc              LDRB     r4,[r1,#0xb]
0000e4  2c01              CMP      r4,#1
0000e6  d104              BNE      |L1.242|
;;;243        {
;;;244          CANx->MCR |= CAN_MCR_TXFP;
0000e8  6814              LDR      r4,[r2,#0]
0000ea  f0440404          ORR      r4,r4,#4
0000ee  6014              STR      r4,[r2,#0]
0000f0  e003              B        |L1.250|
                  |L1.242|
;;;245        }
;;;246        else
;;;247        {
;;;248          CANx->MCR &= ~(uint32_t)CAN_MCR_TXFP;
0000f2  6814              LDR      r4,[r2,#0]
0000f4  f0240404          BIC      r4,r4,#4
0000f8  6014              STR      r4,[r2,#0]
                  |L1.250|
;;;249        }
;;;250    
;;;251        /* Set the bit timing register */
;;;252        CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
0000fa  788c              LDRB     r4,[r1,#2]
0000fc  07a4              LSLS     r4,r4,#30
0000fe  78cd              LDRB     r5,[r1,#3]
000100  ea446405          ORR      r4,r4,r5,LSL #24
000104  790d              LDRB     r5,[r1,#4]
000106  ea444405          ORR      r4,r4,r5,LSL #16
00010a  794d              LDRB     r5,[r1,#5]
00010c  ea445405          ORR      r4,r4,r5,LSL #20
000110  880d              LDRH     r5,[r1,#0]
000112  1e6d              SUBS     r5,r5,#1
000114  432c              ORRS     r4,r4,r5
000116  61d4              STR      r4,[r2,#0x1c]
;;;253                    ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
;;;254                    ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
;;;255                    ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) | \
;;;256                   ((uint32_t)CAN_InitStruct->CAN_Prescaler - 1);
;;;257    
;;;258        /* Request leave initialisation */
;;;259        CANx->MCR &= ~(uint32_t)CAN_MCR_INRQ;
000118  6814              LDR      r4,[r2,#0]
00011a  f0240401          BIC      r4,r4,#1
00011e  6014              STR      r4,[r2,#0]
;;;260    
;;;261       /* Wait the acknowledge */
;;;262       wait_ack = 0;
000120  2300              MOVS     r3,#0
;;;263    
;;;264       while (((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
000122  e000              B        |L1.294|
                  |L1.292|
;;;265       {
;;;266         wait_ack++;
000124  1c5b              ADDS     r3,r3,#1
                  |L1.294|
000126  6854              LDR      r4,[r2,#4]            ;264
000128  f0140f01          TST      r4,#1                 ;264
00012c  d003              BEQ      |L1.310|
00012e  f5a3447f          SUB      r4,r3,#0xff00         ;264
000132  3cff              SUBS     r4,r4,#0xff           ;264
000134  d1f6              BNE      |L1.292|
                  |L1.310|
;;;267       }
;;;268    
;;;269        /* ...and check acknowledged */
;;;270        if ((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
000136  6854              LDR      r4,[r2,#4]
000138  f0140f01          TST      r4,#1
00013c  d001              BEQ      |L1.322|
;;;271        {
;;;272          InitStatus = CAN_InitStatus_Failed;
00013e  2000              MOVS     r0,#0
000140  e000              B        |L1.324|
                  |L1.322|
;;;273        }
;;;274        else
;;;275        {
;;;276          InitStatus = CAN_InitStatus_Success ;
000142  2001              MOVS     r0,#1
                  |L1.324|
;;;277        }
;;;278      }
;;;279    
;;;280      /* At this step, return the status of initialization */
;;;281      return InitStatus;
;;;282    }
000144  bd30              POP      {r4,r5,pc}
;;;283    
                          ENDP

                  CAN_FilterInit PROC
;;;291      */
;;;292    void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
000146  b510              PUSH     {r4,lr}
;;;293    {
;;;294      uint32_t filter_number_bit_pos = 0;
000148  2100              MOVS     r1,#0
;;;295      /* Check the parameters */
;;;296      assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct->CAN_FilterNumber));
;;;297      assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct->CAN_FilterMode));
;;;298      assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct->CAN_FilterScale));
;;;299      assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct->CAN_FilterFIFOAssignment));
;;;300      assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));
;;;301    
;;;302      filter_number_bit_pos = ((uint32_t)1) << CAN_FilterInitStruct->CAN_FilterNumber;
00014a  7a83              LDRB     r3,[r0,#0xa]
00014c  2201              MOVS     r2,#1
00014e  fa02f103          LSL      r1,r2,r3
;;;303    
;;;304      /* Initialisation mode for the filter */
;;;305      CAN1->FMR |= FMR_FINIT;
000152  4aac              LDR      r2,|L1.1028|
000154  6812              LDR      r2,[r2,#0]
000156  f0420201          ORR      r2,r2,#1
00015a  4baa              LDR      r3,|L1.1028|
00015c  601a              STR      r2,[r3,#0]
;;;306    
;;;307      /* Filter Deactivation */
;;;308      CAN1->FA1R &= ~(uint32_t)filter_number_bit_pos;
00015e  4aa9              LDR      r2,|L1.1028|
000160  321c              ADDS     r2,r2,#0x1c
000162  6812              LDR      r2,[r2,#0]
000164  438a              BICS     r2,r2,r1
000166  4ba7              LDR      r3,|L1.1028|
000168  331c              ADDS     r3,r3,#0x1c
00016a  601a              STR      r2,[r3,#0]
;;;309    
;;;310      /* Filter Scale */
;;;311      if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
00016c  7b02              LDRB     r2,[r0,#0xc]
00016e  b9ca              CBNZ     r2,|L1.420|
;;;312      {
;;;313        /* 16-bit scale for the filter */
;;;314        CAN1->FS1R &= ~(uint32_t)filter_number_bit_pos;
000170  4aa4              LDR      r2,|L1.1028|
000172  320c              ADDS     r2,r2,#0xc
000174  6812              LDR      r2,[r2,#0]
000176  438a              BICS     r2,r2,r1
000178  4ba2              LDR      r3,|L1.1028|
00017a  330c              ADDS     r3,r3,#0xc
00017c  601a              STR      r2,[r3,#0]
;;;315    
;;;316        /* First 16-bit identifier and First 16-bit mask */
;;;317        /* Or First 16-bit identifier and Second 16-bit identifier */
;;;318        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
00017e  8842              LDRH     r2,[r0,#2]
000180  88c3              LDRH     r3,[r0,#6]
000182  ea424303          ORR      r3,r2,r3,LSL #16
000186  4a9f              LDR      r2,|L1.1028|
000188  3240              ADDS     r2,r2,#0x40
00018a  7a84              LDRB     r4,[r0,#0xa]
00018c  f8423034          STR      r3,[r2,r4,LSL #3]
;;;319        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
;;;320            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
;;;321    
;;;322        /* Second 16-bit identifier and Second 16-bit mask */
;;;323        /* Or Third 16-bit identifier and Fourth 16-bit identifier */
;;;324        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
000190  8802              LDRH     r2,[r0,#0]
000192  8883              LDRH     r3,[r0,#4]
000194  ea424303          ORR      r3,r2,r3,LSL #16
000198  4a9a              LDR      r2,|L1.1028|
00019a  3240              ADDS     r2,r2,#0x40
00019c  7a84              LDRB     r4,[r0,#0xa]
00019e  eb0202c4          ADD      r2,r2,r4,LSL #3
0001a2  6053              STR      r3,[r2,#4]
                  |L1.420|
;;;325        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
;;;326            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh);
;;;327      }
;;;328    
;;;329      if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
0001a4  7b02              LDRB     r2,[r0,#0xc]
0001a6  2a01              CMP      r2,#1
0001a8  d119              BNE      |L1.478|
;;;330      {
;;;331        /* 32-bit scale for the filter */
;;;332        CAN1->FS1R |= filter_number_bit_pos;
0001aa  4a96              LDR      r2,|L1.1028|
0001ac  320c              ADDS     r2,r2,#0xc
0001ae  6812              LDR      r2,[r2,#0]
0001b0  430a              ORRS     r2,r2,r1
0001b2  4b94              LDR      r3,|L1.1028|
0001b4  330c              ADDS     r3,r3,#0xc
0001b6  601a              STR      r2,[r3,#0]
;;;333        /* 32-bit identifier or First 32-bit identifier */
;;;334        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
0001b8  8842              LDRH     r2,[r0,#2]
0001ba  8803              LDRH     r3,[r0,#0]
0001bc  ea424303          ORR      r3,r2,r3,LSL #16
0001c0  4a90              LDR      r2,|L1.1028|
0001c2  3240              ADDS     r2,r2,#0x40
0001c4  7a84              LDRB     r4,[r0,#0xa]
0001c6  f8423034          STR      r3,[r2,r4,LSL #3]
;;;335        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
;;;336            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
;;;337        /* 32-bit mask or Second 32-bit identifier */
;;;338        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
0001ca  88c2              LDRH     r2,[r0,#6]
0001cc  8883              LDRH     r3,[r0,#4]
0001ce  ea424303          ORR      r3,r2,r3,LSL #16
0001d2  4a8c              LDR      r2,|L1.1028|
0001d4  3240              ADDS     r2,r2,#0x40
0001d6  7a84              LDRB     r4,[r0,#0xa]
0001d8  eb0202c4          ADD      r2,r2,r4,LSL #3
0001dc  6053              STR      r3,[r2,#4]
                  |L1.478|
;;;339        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
;;;340            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow);
;;;341      }
;;;342    
;;;343      /* Filter Mode */
;;;344      if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
0001de  7ac2              LDRB     r2,[r0,#0xb]
0001e0  b93a              CBNZ     r2,|L1.498|
;;;345      {
;;;346        /*Id/Mask mode for the filter*/
;;;347        CAN1->FM1R &= ~(uint32_t)filter_number_bit_pos;
0001e2  4a88              LDR      r2,|L1.1028|
0001e4  1d12              ADDS     r2,r2,#4
0001e6  6812              LDR      r2,[r2,#0]
0001e8  438a              BICS     r2,r2,r1
0001ea  4b86              LDR      r3,|L1.1028|
0001ec  1d1b              ADDS     r3,r3,#4
0001ee  601a              STR      r2,[r3,#0]
0001f0  e006              B        |L1.512|
                  |L1.498|
;;;348      }
;;;349      else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
;;;350      {
;;;351        /*Identifier list mode for the filter*/
;;;352        CAN1->FM1R |= (uint32_t)filter_number_bit_pos;
0001f2  4a84              LDR      r2,|L1.1028|
0001f4  1d12              ADDS     r2,r2,#4
0001f6  6812              LDR      r2,[r2,#0]
0001f8  430a              ORRS     r2,r2,r1
0001fa  4b82              LDR      r3,|L1.1028|
0001fc  1d1b              ADDS     r3,r3,#4
0001fe  601a              STR      r2,[r3,#0]
                  |L1.512|
;;;353      }
;;;354    
;;;355      /* Filter FIFO assignment */
;;;356      if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO0)
000200  8902              LDRH     r2,[r0,#8]
000202  b932              CBNZ     r2,|L1.530|
;;;357      {
;;;358        /* FIFO 0 assignation for the filter */
;;;359        CAN1->FFA1R &= ~(uint32_t)filter_number_bit_pos;
000204  4a7f              LDR      r2,|L1.1028|
000206  3214              ADDS     r2,r2,#0x14
000208  6812              LDR      r2,[r2,#0]
00020a  438a              BICS     r2,r2,r1
00020c  4b7d              LDR      r3,|L1.1028|
00020e  3314              ADDS     r3,r3,#0x14
000210  601a              STR      r2,[r3,#0]
                  |L1.530|
;;;360      }
;;;361    
;;;362      if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO1)
000212  8902              LDRH     r2,[r0,#8]
000214  2a01              CMP      r2,#1
000216  d106              BNE      |L1.550|
;;;363      {
;;;364        /* FIFO 1 assignation for the filter */
;;;365        CAN1->FFA1R |= (uint32_t)filter_number_bit_pos;
000218  4a7a              LDR      r2,|L1.1028|
00021a  3214              ADDS     r2,r2,#0x14
00021c  6812              LDR      r2,[r2,#0]
00021e  430a              ORRS     r2,r2,r1
000220  4b78              LDR      r3,|L1.1028|
000222  3314              ADDS     r3,r3,#0x14
000224  601a              STR      r2,[r3,#0]
                  |L1.550|
;;;366      }
;;;367      
;;;368      /* Filter activation */
;;;369      if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)
000226  7b42              LDRB     r2,[r0,#0xd]
000228  2a01              CMP      r2,#1
00022a  d106              BNE      |L1.570|
;;;370      {
;;;371        CAN1->FA1R |= filter_number_bit_pos;
00022c  4a75              LDR      r2,|L1.1028|
00022e  321c              ADDS     r2,r2,#0x1c
000230  6812              LDR      r2,[r2,#0]
000232  430a              ORRS     r2,r2,r1
000234  4b73              LDR      r3,|L1.1028|
000236  331c              ADDS     r3,r3,#0x1c
000238  601a              STR      r2,[r3,#0]
                  |L1.570|
;;;372      }
;;;373    
;;;374      /* Leave the initialisation mode for the filter */
;;;375      CAN1->FMR &= ~FMR_FINIT;
00023a  4a72              LDR      r2,|L1.1028|
00023c  6812              LDR      r2,[r2,#0]
00023e  f0220201          BIC      r2,r2,#1
000242  4b70              LDR      r3,|L1.1028|
000244  601a              STR      r2,[r3,#0]
;;;376    }
000246  bd10              POP      {r4,pc}
;;;377    
                          ENDP

                  CAN_StructInit PROC
;;;383      */
;;;384    void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
000248  2100              MOVS     r1,#0
;;;385    {
;;;386      /* Reset CAN init structure parameters values */
;;;387      
;;;388      /* Initialize the time triggered communication mode */
;;;389      CAN_InitStruct->CAN_TTCM = DISABLE;
00024a  7181              STRB     r1,[r0,#6]
;;;390      
;;;391      /* Initialize the automatic bus-off management */
;;;392      CAN_InitStruct->CAN_ABOM = DISABLE;
00024c  71c1              STRB     r1,[r0,#7]
;;;393      
;;;394      /* Initialize the automatic wake-up mode */
;;;395      CAN_InitStruct->CAN_AWUM = DISABLE;
00024e  7201              STRB     r1,[r0,#8]
;;;396      
;;;397      /* Initialize the no automatic retransmission */
;;;398      CAN_InitStruct->CAN_NART = DISABLE;
000250  7241              STRB     r1,[r0,#9]
;;;399      
;;;400      /* Initialize the receive FIFO locked mode */
;;;401      CAN_InitStruct->CAN_RFLM = DISABLE;
000252  7281              STRB     r1,[r0,#0xa]
;;;402      
;;;403      /* Initialize the transmit FIFO priority */
;;;404      CAN_InitStruct->CAN_TXFP = DISABLE;
000254  72c1              STRB     r1,[r0,#0xb]
;;;405      
;;;406      /* Initialize the CAN_Mode member */
;;;407      CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;
000256  7081              STRB     r1,[r0,#2]
;;;408      
;;;409      /* Initialize the CAN_SJW member */
;;;410      CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;
000258  70c1              STRB     r1,[r0,#3]
;;;411      
;;;412      /* Initialize the CAN_BS1 member */
;;;413      CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
00025a  2103              MOVS     r1,#3
00025c  7101              STRB     r1,[r0,#4]
;;;414      
;;;415      /* Initialize the CAN_BS2 member */
;;;416      CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
00025e  2102              MOVS     r1,#2
000260  7141              STRB     r1,[r0,#5]
;;;417      
;;;418      /* Initialize the CAN_Prescaler member */
;;;419      CAN_InitStruct->CAN_Prescaler = 1;
000262  2101              MOVS     r1,#1
000264  8001              STRH     r1,[r0,#0]
;;;420    }
000266  4770              BX       lr
;;;421    
                          ENDP

                  CAN_SlaveStartBank PROC
;;;427      */
;;;428    void CAN_SlaveStartBank(uint8_t CAN_BankNumber) 
000268  4966              LDR      r1,|L1.1028|
;;;429    {
;;;430      /* Check the parameters */
;;;431      assert_param(IS_CAN_BANKNUMBER(CAN_BankNumber));
;;;432      
;;;433      /* Enter Initialisation mode for the filter */
;;;434      CAN1->FMR |= FMR_FINIT;
00026a  6809              LDR      r1,[r1,#0]
00026c  f0410101          ORR      r1,r1,#1
000270  4a64              LDR      r2,|L1.1028|
000272  6011              STR      r1,[r2,#0]
;;;435      
;;;436      /* Select the start slave bank */
;;;437      CAN1->FMR &= (uint32_t)0xFFFFC0F1 ;
000274  4611              MOV      r1,r2
000276  6809              LDR      r1,[r1,#0]
000278  f643720e          MOV      r2,#0x3f0e
00027c  4391              BICS     r1,r1,r2
00027e  4a61              LDR      r2,|L1.1028|
000280  6011              STR      r1,[r2,#0]
;;;438      CAN1->FMR |= (uint32_t)(CAN_BankNumber)<<8;
000282  4611              MOV      r1,r2
000284  6809              LDR      r1,[r1,#0]
000286  ea412100          ORR      r1,r1,r0,LSL #8
00028a  6011              STR      r1,[r2,#0]
;;;439      
;;;440      /* Leave Initialisation mode for the filter */
;;;441      CAN1->FMR &= ~FMR_FINIT;
00028c  4611              MOV      r1,r2
00028e  6809              LDR      r1,[r1,#0]
000290  f0210101          BIC      r1,r1,#1
000294  6011              STR      r1,[r2,#0]
;;;442    }
000296  4770              BX       lr
;;;443    
                          ENDP

                  CAN_DBGFreeze PROC
;;;450      */
;;;451    void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState)
000298  b121              CBZ      r1,|L1.676|
;;;452    {
;;;453      /* Check the parameters */
;;;454      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;455      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;456      
;;;457      if (NewState != DISABLE)
;;;458      {
;;;459        /* Enable Debug Freeze  */
;;;460        CANx->MCR |= MCR_DBF;
00029a  6802              LDR      r2,[r0,#0]
00029c  f4423280          ORR      r2,r2,#0x10000
0002a0  6002              STR      r2,[r0,#0]
0002a2  e003              B        |L1.684|
                  |L1.676|
;;;461      }
;;;462      else
;;;463      {
;;;464        /* Disable Debug Freeze */
;;;465        CANx->MCR &= ~MCR_DBF;
0002a4  6802              LDR      r2,[r0,#0]
0002a6  f4223280          BIC      r2,r2,#0x10000
0002aa  6002              STR      r2,[r0,#0]
                  |L1.684|
;;;466      }
;;;467    }
0002ac  4770              BX       lr
;;;468    
                          ENDP

                  CAN_TTComModeCmd PROC
;;;480      */
;;;481    void CAN_TTComModeCmd(CAN_TypeDef* CANx, FunctionalState NewState)
0002ae  b1e1              CBZ      r1,|L1.746|
;;;482    {
;;;483      /* Check the parameters */
;;;484      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;485      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;486      if (NewState != DISABLE)
;;;487      {
;;;488        /* Enable the TTCM mode */
;;;489        CANx->MCR |= CAN_MCR_TTCM;
0002b0  6802              LDR      r2,[r0,#0]
0002b2  f0420280          ORR      r2,r2,#0x80
0002b6  6002              STR      r2,[r0,#0]
;;;490    
;;;491        /* Set TGT bits */
;;;492        CANx->sTxMailBox[0].TDTR |= ((uint32_t)CAN_TDT0R_TGT);
0002b8  f44f72c2          MOV      r2,#0x184
0002bc  5812              LDR      r2,[r2,r0]
0002be  f4427380          ORR      r3,r2,#0x100
0002c2  f44f72c2          MOV      r2,#0x184
0002c6  5013              STR      r3,[r2,r0]
;;;493        CANx->sTxMailBox[1].TDTR |= ((uint32_t)CAN_TDT1R_TGT);
0002c8  f44f72ca          MOV      r2,#0x194
0002cc  5812              LDR      r2,[r2,r0]
0002ce  f4427380          ORR      r3,r2,#0x100
0002d2  f44f72ca          MOV      r2,#0x194
0002d6  5013              STR      r3,[r2,r0]
;;;494        CANx->sTxMailBox[2].TDTR |= ((uint32_t)CAN_TDT2R_TGT);
0002d8  f44f72d2          MOV      r2,#0x1a4
0002dc  5812              LDR      r2,[r2,r0]
0002de  f4427380          ORR      r3,r2,#0x100
0002e2  f44f72d2          MOV      r2,#0x1a4
0002e6  5013              STR      r3,[r2,r0]
0002e8  e01b              B        |L1.802|
                  |L1.746|
;;;495      }
;;;496      else
;;;497      {
;;;498        /* Disable the TTCM mode */
;;;499        CANx->MCR &= (uint32_t)(~(uint32_t)CAN_MCR_TTCM);
0002ea  6802              LDR      r2,[r0,#0]
0002ec  f0220280          BIC      r2,r2,#0x80
0002f0  6002              STR      r2,[r0,#0]
;;;500    
;;;501        /* Reset TGT bits */
;;;502        CANx->sTxMailBox[0].TDTR &= ((uint32_t)~CAN_TDT0R_TGT);
0002f2  f44f72c2          MOV      r2,#0x184
0002f6  5812              LDR      r2,[r2,r0]
0002f8  f4227380          BIC      r3,r2,#0x100
0002fc  f44f72c2          MOV      r2,#0x184
000300  5013              STR      r3,[r2,r0]
;;;503        CANx->sTxMailBox[1].TDTR &= ((uint32_t)~CAN_TDT1R_TGT);
000302  f44f72ca          MOV      r2,#0x194
000306  5812              LDR      r2,[r2,r0]
000308  f4227380          BIC      r3,r2,#0x100
00030c  f44f72ca          MOV      r2,#0x194
000310  5013              STR      r3,[r2,r0]
;;;504        CANx->sTxMailBox[2].TDTR &= ((uint32_t)~CAN_TDT2R_TGT);
000312  f44f72d2          MOV      r2,#0x1a4
000316  5812              LDR      r2,[r2,r0]
000318  f4227380          BIC      r3,r2,#0x100
00031c  f44f72d2          MOV      r2,#0x1a4
000320  5013              STR      r3,[r2,r0]
                  |L1.802|
;;;505      }
;;;506    }
000322  4770              BX       lr
;;;507    /**
                          ENDP

                  CAN_Transmit PROC
;;;514      */
;;;515    uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage)
000324  b510              PUSH     {r4,lr}
;;;516    {
000326  4602              MOV      r2,r0
;;;517      uint8_t transmit_mailbox = 0;
000328  2000              MOVS     r0,#0
;;;518      /* Check the parameters */
;;;519      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;520      assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
;;;521      assert_param(IS_CAN_RTR(TxMessage->RTR));
;;;522      assert_param(IS_CAN_DLC(TxMessage->DLC));
;;;523    
;;;524      /* Select one empty transmit mailbox */
;;;525      if ((CANx->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
00032a  6893              LDR      r3,[r2,#8]
00032c  f0036380          AND      r3,r3,#0x4000000
000330  f1b36f80          CMP      r3,#0x4000000
000334  d100              BNE      |L1.824|
;;;526      {
;;;527        transmit_mailbox = 0;
000336  e010              B        |L1.858|
                  |L1.824|
;;;528      }
;;;529      else if ((CANx->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
000338  6893              LDR      r3,[r2,#8]
00033a  f0036300          AND      r3,r3,#0x8000000
00033e  f1b36f00          CMP      r3,#0x8000000
000342  d101              BNE      |L1.840|
;;;530      {
;;;531        transmit_mailbox = 1;
000344  2001              MOVS     r0,#1
000346  e008              B        |L1.858|
                  |L1.840|
;;;532      }
;;;533      else if ((CANx->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
000348  6893              LDR      r3,[r2,#8]
00034a  f0035380          AND      r3,r3,#0x10000000
00034e  f1b35f80          CMP      r3,#0x10000000
000352  d101              BNE      |L1.856|
;;;534      {
;;;535        transmit_mailbox = 2;
000354  2002              MOVS     r0,#2
000356  e000              B        |L1.858|
                  |L1.856|
;;;536      }
;;;537      else
;;;538      {
;;;539        transmit_mailbox = CAN_TxStatus_NoMailBox;
000358  2004              MOVS     r0,#4
                  |L1.858|
;;;540      }
;;;541    
;;;542      if (transmit_mailbox != CAN_TxStatus_NoMailBox)
00035a  2804              CMP      r0,#4
00035c  d079              BEQ      |L1.1106|
;;;543      {
;;;544        /* Set up the Id */
;;;545        CANx->sTxMailBox[transmit_mailbox].TIR &= TMIDxR_TXRQ;
00035e  f50273c0          ADD      r3,r2,#0x180
000362  eb031300          ADD      r3,r3,r0,LSL #4
000366  681b              LDR      r3,[r3,#0]
000368  f0030401          AND      r4,r3,#1
00036c  f50273c0          ADD      r3,r2,#0x180
000370  eb031300          ADD      r3,r3,r0,LSL #4
000374  601c              STR      r4,[r3,#0]
;;;546        if (TxMessage->IDE == CAN_Id_Standard)
000376  7a0b              LDRB     r3,[r1,#8]
000378  b97b              CBNZ     r3,|L1.922|
;;;547        {
;;;548          assert_param(IS_CAN_STDID(TxMessage->StdId));  
;;;549          CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->StdId << 21) | \
00037a  7a4b              LDRB     r3,[r1,#9]
00037c  880c              LDRH     r4,[r1,#0]
00037e  ea435344          ORR      r3,r3,r4,LSL #21
000382  f50274c0          ADD      r4,r2,#0x180
000386  eb041400          ADD      r4,r4,r0,LSL #4
00038a  6824              LDR      r4,[r4,#0]
00038c  4323              ORRS     r3,r3,r4
00038e  f50274c0          ADD      r4,r2,#0x180
000392  eb041400          ADD      r4,r4,r0,LSL #4
000396  6023              STR      r3,[r4,#0]
000398  e010              B        |L1.956|
                  |L1.922|
;;;550                                                      TxMessage->RTR);
;;;551        }
;;;552        else
;;;553        {
;;;554          assert_param(IS_CAN_EXTID(TxMessage->ExtId));
;;;555          CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId << 3) | \
00039a  7a0b              LDRB     r3,[r1,#8]
00039c  684c              LDR      r4,[r1,#4]
00039e  ea4303c4          ORR      r3,r3,r4,LSL #3
0003a2  7a4c              LDRB     r4,[r1,#9]
0003a4  4323              ORRS     r3,r3,r4
0003a6  f50274c0          ADD      r4,r2,#0x180
0003aa  eb041400          ADD      r4,r4,r0,LSL #4
0003ae  6824              LDR      r4,[r4,#0]
0003b0  4323              ORRS     r3,r3,r4
0003b2  f50274c0          ADD      r4,r2,#0x180
0003b6  eb041400          ADD      r4,r4,r0,LSL #4
0003ba  6023              STR      r3,[r4,#0]
                  |L1.956|
;;;556                                                      TxMessage->IDE | \
;;;557                                                      TxMessage->RTR);
;;;558        }
;;;559        
;;;560        /* Set up the DLC */
;;;561        TxMessage->DLC &= (uint8_t)0x0000000F;
0003bc  7a8b              LDRB     r3,[r1,#0xa]
0003be  f003030f          AND      r3,r3,#0xf
0003c2  728b              STRB     r3,[r1,#0xa]
;;;562        CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
0003c4  f50273c0          ADD      r3,r2,#0x180
0003c8  eb031300          ADD      r3,r3,r0,LSL #4
0003cc  685b              LDR      r3,[r3,#4]
0003ce  f023040f          BIC      r4,r3,#0xf
0003d2  f50273c0          ADD      r3,r2,#0x180
0003d6  eb031300          ADD      r3,r3,r0,LSL #4
0003da  605c              STR      r4,[r3,#4]
;;;563        CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;
0003dc  f50273c0          ADD      r3,r2,#0x180
0003e0  eb031300          ADD      r3,r3,r0,LSL #4
0003e4  685b              LDR      r3,[r3,#4]
0003e6  7a8c              LDRB     r4,[r1,#0xa]
0003e8  4323              ORRS     r3,r3,r4
0003ea  f50274c0          ADD      r4,r2,#0x180
0003ee  eb041400          ADD      r4,r4,r0,LSL #4
0003f2  6063              STR      r3,[r4,#4]
;;;564    
;;;565        /* Set up the data field */
;;;566        CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
0003f4  7b8b              LDRB     r3,[r1,#0xe]
0003f6  061c              LSLS     r4,r3,#24
0003f8  7b4b              LDRB     r3,[r1,#0xd]
0003fa  ea444403          ORR      r4,r4,r3,LSL #16
0003fe  e003              B        |L1.1032|
                  |L1.1024|
                          DCD      0x40006400
                  |L1.1028|
                          DCD      0x40006600
                  |L1.1032|
000408  7b0b              LDRB     r3,[r1,#0xc]
00040a  ea442303          ORR      r3,r4,r3,LSL #8
00040e  7acc              LDRB     r4,[r1,#0xb]
000410  4323              ORRS     r3,r3,r4
000412  f50274c0          ADD      r4,r2,#0x180
000416  eb041400          ADD      r4,r4,r0,LSL #4
00041a  60a3              STR      r3,[r4,#8]
;;;567                                                 ((uint32_t)TxMessage->Data[2] << 16) |
;;;568                                                 ((uint32_t)TxMessage->Data[1] << 8) | 
;;;569                                                 ((uint32_t)TxMessage->Data[0]));
;;;570        CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
00041c  7c8b              LDRB     r3,[r1,#0x12]
00041e  061c              LSLS     r4,r3,#24
000420  7c4b              LDRB     r3,[r1,#0x11]
000422  ea444403          ORR      r4,r4,r3,LSL #16
000426  7c0b              LDRB     r3,[r1,#0x10]
000428  ea442303          ORR      r3,r4,r3,LSL #8
00042c  7bcc              LDRB     r4,[r1,#0xf]
00042e  4323              ORRS     r3,r3,r4
000430  f50274c0          ADD      r4,r2,#0x180
000434  eb041400          ADD      r4,r4,r0,LSL #4
000438  60e3              STR      r3,[r4,#0xc]
;;;571                                                 ((uint32_t)TxMessage->Data[6] << 16) |
;;;572                                                 ((uint32_t)TxMessage->Data[5] << 8) |
;;;573                                                 ((uint32_t)TxMessage->Data[4]));
;;;574        /* Request transmission */
;;;575        CANx->sTxMailBox[transmit_mailbox].TIR |= TMIDxR_TXRQ;
00043a  f50273c0          ADD      r3,r2,#0x180
00043e  eb031300          ADD      r3,r3,r0,LSL #4
000442  681b              LDR      r3,[r3,#0]
000444  f0430401          ORR      r4,r3,#1
000448  f50273c0          ADD      r3,r2,#0x180
00044c  eb031300          ADD      r3,r3,r0,LSL #4
000450  601c              STR      r4,[r3,#0]
                  |L1.1106|
;;;576      }
;;;577      return transmit_mailbox;
;;;578    }
000452  bd10              POP      {r4,pc}
;;;579    
                          ENDP

                  CAN_TransmitStatus PROC
;;;588      */
;;;589    uint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox)
000454  b510              PUSH     {r4,lr}
;;;590    {
000456  4602              MOV      r2,r0
;;;591      uint32_t state = 0;
000458  2300              MOVS     r3,#0
;;;592    
;;;593      /* Check the parameters */
;;;594      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;595      assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
;;;596     
;;;597      switch (TransmitMailbox)
00045a  b121              CBZ      r1,|L1.1126|
00045c  2901              CMP      r1,#1
00045e  d007              BEQ      |L1.1136|
000460  2902              CMP      r1,#2
000462  d10f              BNE      |L1.1156|
000464  e009              B        |L1.1146|
                  |L1.1126|
;;;598      {
;;;599        case (CAN_TXMAILBOX_0): 
;;;600          state =   CANx->TSR &  (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0);
000466  6890              LDR      r0,[r2,#8]
000468  4cf8              LDR      r4,|L1.2124|
00046a  ea000304          AND      r3,r0,r4
;;;601          break;
00046e  e00b              B        |L1.1160|
                  |L1.1136|
;;;602        case (CAN_TXMAILBOX_1): 
;;;603          state =   CANx->TSR &  (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1);
000470  6890              LDR      r0,[r2,#8]
000472  4cf7              LDR      r4,|L1.2128|
000474  ea000304          AND      r3,r0,r4
;;;604          break;
000478  e006              B        |L1.1160|
                  |L1.1146|
;;;605        case (CAN_TXMAILBOX_2): 
;;;606          state =   CANx->TSR &  (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2);
00047a  6890              LDR      r0,[r2,#8]
00047c  4cf5              LDR      r4,|L1.2132|
00047e  ea000304          AND      r3,r0,r4
;;;607          break;
000482  e001              B        |L1.1160|
                  |L1.1156|
;;;608        default:
;;;609          state = CAN_TxStatus_Failed;
000484  2300              MOVS     r3,#0
;;;610          break;
000486  bf00              NOP      
                  |L1.1160|
000488  bf00              NOP                            ;601
;;;611      }
;;;612      switch (state)
00048a  4cf3              LDR      r4,|L1.2136|
00048c  1b18              SUBS     r0,r3,r4
00048e  42a3              CMP      r3,r4
000490  d016              BEQ      |L1.1216|
000492  dc07              BGT      |L1.1188|
000494  b183              CBZ      r3,|L1.1208|
000496  f06f6080          MVN      r0,#0x4000000
00049a  1818              ADDS     r0,r3,r0
00049c  d00e              BEQ      |L1.1212|
00049e  2802              CMP      r0,#2
0004a0  d118              BNE      |L1.1236|
0004a2  e011              B        |L1.1224|
                  |L1.1188|
0004a4  f5b07f00          CMP      r0,#0x200
0004a8  d010              BEQ      |L1.1228|
0004aa  4cec              LDR      r4,|L1.2140|
0004ac  1900              ADDS     r0,r0,r4
0004ae  d009              BEQ      |L1.1220|
0004b0  f5b03f00          CMP      r0,#0x20000
0004b4  d10e              BNE      |L1.1236|
0004b6  e00b              B        |L1.1232|
                  |L1.1208|
;;;613      {
;;;614          /* transmit pending  */
;;;615        case (0x0): state = CAN_TxStatus_Pending;
0004b8  2302              MOVS     r3,#2
;;;616          break;
0004ba  e00d              B        |L1.1240|
                  |L1.1212|
;;;617          /* transmit failed  */
;;;618         case (CAN_TSR_RQCP0 | CAN_TSR_TME0): state = CAN_TxStatus_Failed;
0004bc  2300              MOVS     r3,#0
;;;619          break;
0004be  e00b              B        |L1.1240|
                  |L1.1216|
;;;620         case (CAN_TSR_RQCP1 | CAN_TSR_TME1): state = CAN_TxStatus_Failed;
0004c0  2300              MOVS     r3,#0
;;;621          break;
0004c2  e009              B        |L1.1240|
                  |L1.1220|
;;;622         case (CAN_TSR_RQCP2 | CAN_TSR_TME2): state = CAN_TxStatus_Failed;
0004c4  2300              MOVS     r3,#0
;;;623          break;
0004c6  e007              B        |L1.1240|
                  |L1.1224|
;;;624          /* transmit succeeded  */
;;;625        case (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0):state = CAN_TxStatus_Ok;
0004c8  2301              MOVS     r3,#1
;;;626          break;
0004ca  e005              B        |L1.1240|
                  |L1.1228|
;;;627        case (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1):state = CAN_TxStatus_Ok;
0004cc  2301              MOVS     r3,#1
;;;628          break;
0004ce  e003              B        |L1.1240|
                  |L1.1232|
;;;629        case (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2):state = CAN_TxStatus_Ok;
0004d0  2301              MOVS     r3,#1
;;;630          break;
0004d2  e001              B        |L1.1240|
                  |L1.1236|
;;;631        default: state = CAN_TxStatus_Failed;
0004d4  2300              MOVS     r3,#0
;;;632          break;
0004d6  bf00              NOP      
                  |L1.1240|
0004d8  bf00              NOP                            ;616
;;;633      }
;;;634      return (uint8_t) state;
0004da  b2d8              UXTB     r0,r3
;;;635    }
0004dc  bd10              POP      {r4,pc}
;;;636    
                          ENDP

                  CAN_CancelTransmit PROC
;;;642      */
;;;643    void CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox)
0004de  b121              CBZ      r1,|L1.1258|
;;;644    {
;;;645      /* Check the parameters */
;;;646      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;647      assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
;;;648      /* abort transmission */
;;;649      switch (Mailbox)
0004e0  2901              CMP      r1,#1
0004e2  d007              BEQ      |L1.1268|
0004e4  2902              CMP      r1,#2
0004e6  d10f              BNE      |L1.1288|
0004e8  e009              B        |L1.1278|
                  |L1.1258|
;;;650      {
;;;651        case (CAN_TXMAILBOX_0): CANx->TSR |= CAN_TSR_ABRQ0;
0004ea  6882              LDR      r2,[r0,#8]
0004ec  f0420280          ORR      r2,r2,#0x80
0004f0  6082              STR      r2,[r0,#8]
;;;652          break;
0004f2  e00a              B        |L1.1290|
                  |L1.1268|
;;;653        case (CAN_TXMAILBOX_1): CANx->TSR |= CAN_TSR_ABRQ1;
0004f4  6882              LDR      r2,[r0,#8]
0004f6  f4424200          ORR      r2,r2,#0x8000
0004fa  6082              STR      r2,[r0,#8]
;;;654          break;
0004fc  e005              B        |L1.1290|
                  |L1.1278|
;;;655        case (CAN_TXMAILBOX_2): CANx->TSR |= CAN_TSR_ABRQ2;
0004fe  6882              LDR      r2,[r0,#8]
000500  f4420200          ORR      r2,r2,#0x800000
000504  6082              STR      r2,[r0,#8]
;;;656          break;
000506  e000              B        |L1.1290|
                  |L1.1288|
;;;657        default:
;;;658          break;
000508  bf00              NOP      
                  |L1.1290|
00050a  bf00              NOP                            ;652
;;;659      }
;;;660    }
00050c  4770              BX       lr
;;;661    
                          ENDP

                  CAN_Receive PROC
;;;670      */
;;;671    void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage)
00050e  b510              PUSH     {r4,lr}
;;;672    {
;;;673      /* Check the parameters */
;;;674      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;675      assert_param(IS_CAN_FIFO(FIFONumber));
;;;676      /* Get the Id */
;;;677      RxMessage->IDE = (uint8_t)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
000510  f50073d8          ADD      r3,r0,#0x1b0
000514  eb031301          ADD      r3,r3,r1,LSL #4
000518  681b              LDR      r3,[r3,#0]
00051a  f0030304          AND      r3,r3,#4
00051e  7213              STRB     r3,[r2,#8]
;;;678      if (RxMessage->IDE == CAN_Id_Standard)
000520  7a13              LDRB     r3,[r2,#8]
000522  b953              CBNZ     r3,|L1.1338|
;;;679      {
;;;680        RxMessage->StdId = (uint32_t)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
000524  f50073d8          ADD      r3,r0,#0x1b0
000528  eb031301          ADD      r3,r3,r1,LSL #4
00052c  681b              LDR      r3,[r3,#0]
00052e  f24074ff          MOV      r4,#0x7ff
000532  ea045353          AND      r3,r4,r3,LSR #21
000536  6013              STR      r3,[r2,#0]
000538  e009              B        |L1.1358|
                  |L1.1338|
;;;681      }
;;;682      else
;;;683      {
;;;684        RxMessage->ExtId = (uint32_t)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);
00053a  f50073d8          ADD      r3,r0,#0x1b0
00053e  eb031301          ADD      r3,r3,r1,LSL #4
000542  681b              LDR      r3,[r3,#0]
000544  f06f4460          MVN      r4,#0xe0000000
000548  ea0403d3          AND      r3,r4,r3,LSR #3
00054c  6053              STR      r3,[r2,#4]
                  |L1.1358|
;;;685      }
;;;686      
;;;687      RxMessage->RTR = (uint8_t)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;
00054e  f50073d8          ADD      r3,r0,#0x1b0
000552  eb031301          ADD      r3,r3,r1,LSL #4
000556  681b              LDR      r3,[r3,#0]
000558  f0030302          AND      r3,r3,#2
00055c  7253              STRB     r3,[r2,#9]
;;;688      /* Get the DLC */
;;;689      RxMessage->DLC = (uint8_t)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;
00055e  f50073d8          ADD      r3,r0,#0x1b0
000562  eb031301          ADD      r3,r3,r1,LSL #4
000566  685b              LDR      r3,[r3,#4]
000568  f003030f          AND      r3,r3,#0xf
00056c  7293              STRB     r3,[r2,#0xa]
;;;690      /* Get the FMI */
;;;691      RxMessage->FMI = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);
00056e  f50073d8          ADD      r3,r0,#0x1b0
000572  eb031301          ADD      r3,r3,r1,LSL #4
000576  685b              LDR      r3,[r3,#4]
000578  0a1b              LSRS     r3,r3,#8
00057a  74d3              STRB     r3,[r2,#0x13]
;;;692      /* Get the data field */
;;;693      RxMessage->Data[0] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;
00057c  f50073d8          ADD      r3,r0,#0x1b0
000580  eb031301          ADD      r3,r3,r1,LSL #4
000584  689b              LDR      r3,[r3,#8]
000586  72d3              STRB     r3,[r2,#0xb]
;;;694      RxMessage->Data[1] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
000588  f50073d8          ADD      r3,r0,#0x1b0
00058c  eb031301          ADD      r3,r3,r1,LSL #4
000590  689b              LDR      r3,[r3,#8]
000592  0a1c              LSRS     r4,r3,#8
000594  7314              STRB     r4,[r2,#0xc]
;;;695      RxMessage->Data[2] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);
000596  f50073d8          ADD      r3,r0,#0x1b0
00059a  eb031301          ADD      r3,r3,r1,LSL #4
00059e  689b              LDR      r3,[r3,#8]
0005a0  0c1c              LSRS     r4,r3,#16
0005a2  7354              STRB     r4,[r2,#0xd]
;;;696      RxMessage->Data[3] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);
0005a4  f50073d8          ADD      r3,r0,#0x1b0
0005a8  eb031301          ADD      r3,r3,r1,LSL #4
0005ac  689b              LDR      r3,[r3,#8]
0005ae  0e1b              LSRS     r3,r3,#24
0005b0  7393              STRB     r3,[r2,#0xe]
;;;697      RxMessage->Data[4] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;
0005b2  f50073d8          ADD      r3,r0,#0x1b0
0005b6  eb031301          ADD      r3,r3,r1,LSL #4
0005ba  68db              LDR      r3,[r3,#0xc]
0005bc  73d3              STRB     r3,[r2,#0xf]
;;;698      RxMessage->Data[5] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);
0005be  f50073d8          ADD      r3,r0,#0x1b0
0005c2  eb031301          ADD      r3,r3,r1,LSL #4
0005c6  68db              LDR      r3,[r3,#0xc]
0005c8  0a1c              LSRS     r4,r3,#8
0005ca  7414              STRB     r4,[r2,#0x10]
;;;699      RxMessage->Data[6] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);
0005cc  f50073d8          ADD      r3,r0,#0x1b0
0005d0  eb031301          ADD      r3,r3,r1,LSL #4
0005d4  68db              LDR      r3,[r3,#0xc]
0005d6  0c1c              LSRS     r4,r3,#16
0005d8  7454              STRB     r4,[r2,#0x11]
;;;700      RxMessage->Data[7] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);
0005da  f50073d8          ADD      r3,r0,#0x1b0
0005de  eb031301          ADD      r3,r3,r1,LSL #4
0005e2  68db              LDR      r3,[r3,#0xc]
0005e4  0e1b              LSRS     r3,r3,#24
0005e6  7493              STRB     r3,[r2,#0x12]
;;;701      /* Release the FIFO */
;;;702      /* Release FIFO0 */
;;;703      if (FIFONumber == CAN_FIFO0)
0005e8  b921              CBNZ     r1,|L1.1524|
;;;704      {
;;;705        CANx->RF0R |= CAN_RF0R_RFOM0;
0005ea  68c3              LDR      r3,[r0,#0xc]
0005ec  f0430320          ORR      r3,r3,#0x20
0005f0  60c3              STR      r3,[r0,#0xc]
0005f2  e003              B        |L1.1532|
                  |L1.1524|
;;;706      }
;;;707      /* Release FIFO1 */
;;;708      else /* FIFONumber == CAN_FIFO1 */
;;;709      {
;;;710        CANx->RF1R |= CAN_RF1R_RFOM1;
0005f4  6903              LDR      r3,[r0,#0x10]
0005f6  f0430320          ORR      r3,r3,#0x20
0005fa  6103              STR      r3,[r0,#0x10]
                  |L1.1532|
;;;711      }
;;;712    }
0005fc  bd10              POP      {r4,pc}
;;;713    
                          ENDP

                  CAN_FIFORelease PROC
;;;719      */
;;;720    void CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber)
0005fe  b921              CBNZ     r1,|L1.1546|
;;;721    {
;;;722      /* Check the parameters */
;;;723      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;724      assert_param(IS_CAN_FIFO(FIFONumber));
;;;725      /* Release FIFO0 */
;;;726      if (FIFONumber == CAN_FIFO0)
;;;727      {
;;;728        CANx->RF0R |= CAN_RF0R_RFOM0;
000600  68c2              LDR      r2,[r0,#0xc]
000602  f0420220          ORR      r2,r2,#0x20
000606  60c2              STR      r2,[r0,#0xc]
000608  e003              B        |L1.1554|
                  |L1.1546|
;;;729      }
;;;730      /* Release FIFO1 */
;;;731      else /* FIFONumber == CAN_FIFO1 */
;;;732      {
;;;733        CANx->RF1R |= CAN_RF1R_RFOM1;
00060a  6902              LDR      r2,[r0,#0x10]
00060c  f0420220          ORR      r2,r2,#0x20
000610  6102              STR      r2,[r0,#0x10]
                  |L1.1554|
;;;734      }
;;;735    }
000612  4770              BX       lr
;;;736    
                          ENDP

                  CAN_MessagePending PROC
;;;742      */
;;;743    uint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber)
000614  4602              MOV      r2,r0
;;;744    {
;;;745      uint8_t message_pending=0;
000616  2000              MOVS     r0,#0
;;;746      /* Check the parameters */
;;;747      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;748      assert_param(IS_CAN_FIFO(FIFONumber));
;;;749      if (FIFONumber == CAN_FIFO0)
000618  b919              CBNZ     r1,|L1.1570|
;;;750      {
;;;751        message_pending = (uint8_t)(CANx->RF0R&(uint32_t)0x03);
00061a  68d3              LDR      r3,[r2,#0xc]
00061c  f0030003          AND      r0,r3,#3
000620  e006              B        |L1.1584|
                  |L1.1570|
;;;752      }
;;;753      else if (FIFONumber == CAN_FIFO1)
000622  2901              CMP      r1,#1
000624  d103              BNE      |L1.1582|
;;;754      {
;;;755        message_pending = (uint8_t)(CANx->RF1R&(uint32_t)0x03);
000626  6913              LDR      r3,[r2,#0x10]
000628  f0030003          AND      r0,r3,#3
00062c  e000              B        |L1.1584|
                  |L1.1582|
;;;756      }
;;;757      else
;;;758      {
;;;759        message_pending = 0;
00062e  2000              MOVS     r0,#0
                  |L1.1584|
;;;760      }
;;;761      return message_pending;
;;;762    }
000630  4770              BX       lr
;;;763    
                          ENDP

                  CAN_OperatingModeRequest PROC
;;;773      */
;;;774    uint8_t CAN_OperatingModeRequest(CAN_TypeDef* CANx, uint8_t CAN_OperatingMode)
000632  b510              PUSH     {r4,lr}
;;;775    {
000634  4602              MOV      r2,r0
000636  460b              MOV      r3,r1
;;;776      uint8_t status = CAN_ModeStatus_Failed;
000638  2000              MOVS     r0,#0
;;;777      
;;;778      /* Timeout for INAK or also for SLAK bits*/
;;;779      uint32_t timeout = INAK_TIMEOUT; 
00063a  f64f71ff          MOV      r1,#0xffff
;;;780    
;;;781      /* Check the parameters */
;;;782      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;783      assert_param(IS_CAN_OPERATING_MODE(CAN_OperatingMode));
;;;784    
;;;785      if (CAN_OperatingMode == CAN_OperatingMode_Initialization)
00063e  b9bb              CBNZ     r3,|L1.1648|
;;;786      {
;;;787        /* Request initialisation */
;;;788        CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_SLEEP)) | CAN_MCR_INRQ);
000640  6814              LDR      r4,[r2,#0]
000642  f0240402          BIC      r4,r4,#2
000646  f0440401          ORR      r4,r4,#1
00064a  6014              STR      r4,[r2,#0]
;;;789    
;;;790        /* Wait the acknowledge */
;;;791        while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK) && (timeout != 0))
00064c  e000              B        |L1.1616|
                  |L1.1614|
;;;792        {
;;;793          timeout--;
00064e  1e49              SUBS     r1,r1,#1
                  |L1.1616|
000650  6854              LDR      r4,[r2,#4]            ;791
000652  f0040403          AND      r4,r4,#3              ;791
000656  2c01              CMP      r4,#1                 ;791
000658  d001              BEQ      |L1.1630|
00065a  2900              CMP      r1,#0                 ;791
00065c  d1f7              BNE      |L1.1614|
                  |L1.1630|
;;;794        }
;;;795        if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK)
00065e  6854              LDR      r4,[r2,#4]
000660  f0040403          AND      r4,r4,#3
000664  2c01              CMP      r4,#1
000666  d001              BEQ      |L1.1644|
;;;796        {
;;;797          status = CAN_ModeStatus_Failed;
000668  2000              MOVS     r0,#0
00066a  e032              B        |L1.1746|
                  |L1.1644|
;;;798        }
;;;799        else
;;;800        {
;;;801          status = CAN_ModeStatus_Success;
00066c  2001              MOVS     r0,#1
00066e  e030              B        |L1.1746|
                  |L1.1648|
;;;802        }
;;;803      }
;;;804      else  if (CAN_OperatingMode == CAN_OperatingMode_Normal)
000670  2b01              CMP      r3,#1
000672  d113              BNE      |L1.1692|
;;;805      {
;;;806        /* Request leave initialisation and sleep mode  and enter Normal mode */
;;;807        CANx->MCR &= (uint32_t)(~(CAN_MCR_SLEEP|CAN_MCR_INRQ));
000674  6814              LDR      r4,[r2,#0]
000676  f0240403          BIC      r4,r4,#3
00067a  6014              STR      r4,[r2,#0]
;;;808    
;;;809        /* Wait the acknowledge */
;;;810        while (((CANx->MSR & CAN_MODE_MASK) != 0) && (timeout!=0))
00067c  e000              B        |L1.1664|
                  |L1.1662|
;;;811        {
;;;812          timeout--;
00067e  1e49              SUBS     r1,r1,#1
                  |L1.1664|
000680  6854              LDR      r4,[r2,#4]            ;810
000682  f0140f03          TST      r4,#3                 ;810
000686  d001              BEQ      |L1.1676|
000688  2900              CMP      r1,#0                 ;810
00068a  d1f8              BNE      |L1.1662|
                  |L1.1676|
;;;813        }
;;;814        if ((CANx->MSR & CAN_MODE_MASK) != 0)
00068c  6854              LDR      r4,[r2,#4]
00068e  f0140f03          TST      r4,#3
000692  d001              BEQ      |L1.1688|
;;;815        {
;;;816          status = CAN_ModeStatus_Failed;
000694  2000              MOVS     r0,#0
000696  e01c              B        |L1.1746|
                  |L1.1688|
;;;817        }
;;;818        else
;;;819        {
;;;820          status = CAN_ModeStatus_Success;
000698  2001              MOVS     r0,#1
00069a  e01a              B        |L1.1746|
                  |L1.1692|
;;;821        }
;;;822      }
;;;823      else  if (CAN_OperatingMode == CAN_OperatingMode_Sleep)
00069c  2b02              CMP      r3,#2
00069e  d117              BNE      |L1.1744|
;;;824      {
;;;825        /* Request Sleep mode */
;;;826        CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
0006a0  6814              LDR      r4,[r2,#0]
0006a2  f0240401          BIC      r4,r4,#1
0006a6  f0440402          ORR      r4,r4,#2
0006aa  6014              STR      r4,[r2,#0]
;;;827    
;;;828        /* Wait the acknowledge */
;;;829        while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK) && (timeout!=0))
0006ac  e000              B        |L1.1712|
                  |L1.1710|
;;;830        {
;;;831          timeout--;
0006ae  1e49              SUBS     r1,r1,#1
                  |L1.1712|
0006b0  6854              LDR      r4,[r2,#4]            ;829
0006b2  f0040403          AND      r4,r4,#3              ;829
0006b6  2c02              CMP      r4,#2                 ;829
0006b8  d001              BEQ      |L1.1726|
0006ba  2900              CMP      r1,#0                 ;829
0006bc  d1f7              BNE      |L1.1710|
                  |L1.1726|
;;;832        }
;;;833        if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK)
0006be  6854              LDR      r4,[r2,#4]
0006c0  f0040403          AND      r4,r4,#3
0006c4  2c02              CMP      r4,#2
0006c6  d001              BEQ      |L1.1740|
;;;834        {
;;;835          status = CAN_ModeStatus_Failed;
0006c8  2000              MOVS     r0,#0
0006ca  e002              B        |L1.1746|
                  |L1.1740|
;;;836        }
;;;837        else
;;;838        {
;;;839          status = CAN_ModeStatus_Success;
0006cc  2001              MOVS     r0,#1
0006ce  e000              B        |L1.1746|
                  |L1.1744|
;;;840        }
;;;841      }
;;;842      else
;;;843      {
;;;844        status = CAN_ModeStatus_Failed;
0006d0  2000              MOVS     r0,#0
                  |L1.1746|
;;;845      }
;;;846    
;;;847      return  (uint8_t) status;
;;;848    }
0006d2  bd10              POP      {r4,pc}
;;;849    
                          ENDP

                  CAN_Sleep PROC
;;;855      */
;;;856    uint8_t CAN_Sleep(CAN_TypeDef* CANx)
0006d4  4601              MOV      r1,r0
;;;857    {
;;;858      uint8_t sleepstatus = CAN_Sleep_Failed;
0006d6  2000              MOVS     r0,#0
;;;859      
;;;860      /* Check the parameters */
;;;861      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;862        
;;;863      /* Request Sleep mode */
;;;864       CANx->MCR = (((CANx->MCR) & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
0006d8  680a              LDR      r2,[r1,#0]
0006da  f0220201          BIC      r2,r2,#1
0006de  f0420202          ORR      r2,r2,#2
0006e2  600a              STR      r2,[r1,#0]
;;;865       
;;;866      /* Sleep mode status */
;;;867      if ((CANx->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) == CAN_MSR_SLAK)
0006e4  684a              LDR      r2,[r1,#4]
0006e6  f0020203          AND      r2,r2,#3
0006ea  2a02              CMP      r2,#2
0006ec  d100              BNE      |L1.1776|
;;;868      {
;;;869        /* Sleep mode not entered */
;;;870        sleepstatus =  CAN_Sleep_Ok;
0006ee  2001              MOVS     r0,#1
                  |L1.1776|
;;;871      }
;;;872      /* return sleep mode status */
;;;873       return (uint8_t)sleepstatus;
;;;874    }
0006f0  4770              BX       lr
;;;875    
                          ENDP

                  CAN_WakeUp PROC
;;;881      */
;;;882    uint8_t CAN_WakeUp(CAN_TypeDef* CANx)
0006f2  4601              MOV      r1,r0
;;;883    {
;;;884      uint32_t wait_slak = SLAK_TIMEOUT;
0006f4  f64f72ff          MOV      r2,#0xffff
;;;885      uint8_t wakeupstatus = CAN_WakeUp_Failed;
0006f8  2000              MOVS     r0,#0
;;;886      
;;;887      /* Check the parameters */
;;;888      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;889        
;;;890      /* Wake up request */
;;;891      CANx->MCR &= ~(uint32_t)CAN_MCR_SLEEP;
0006fa  680b              LDR      r3,[r1,#0]
0006fc  f0230302          BIC      r3,r3,#2
000700  600b              STR      r3,[r1,#0]
;;;892        
;;;893      /* Sleep mode status */
;;;894      while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(wait_slak!=0x00))
000702  e000              B        |L1.1798|
                  |L1.1796|
;;;895      {
;;;896       wait_slak--;
000704  1e52              SUBS     r2,r2,#1
                  |L1.1798|
000706  684b              LDR      r3,[r1,#4]            ;894
000708  f0030302          AND      r3,r3,#2              ;894
00070c  2b02              CMP      r3,#2                 ;894
00070e  d101              BNE      |L1.1812|
000710  2a00              CMP      r2,#0                 ;894
000712  d1f7              BNE      |L1.1796|
                  |L1.1812|
;;;897      }
;;;898      if((CANx->MSR & CAN_MSR_SLAK) != CAN_MSR_SLAK)
000714  684b              LDR      r3,[r1,#4]
000716  f0030302          AND      r3,r3,#2
00071a  2b02              CMP      r3,#2
00071c  d000              BEQ      |L1.1824|
;;;899      {
;;;900       /* wake up done : Sleep mode exited */
;;;901        wakeupstatus = CAN_WakeUp_Ok;
00071e  2001              MOVS     r0,#1
                  |L1.1824|
;;;902      }
;;;903      /* return wakeup status */
;;;904      return (uint8_t)wakeupstatus;
;;;905    }
000720  4770              BX       lr
;;;906    
                          ENDP

                  CAN_GetLastErrorCode PROC
;;;921     
;;;922    uint8_t CAN_GetLastErrorCode(CAN_TypeDef* CANx)
000722  4601              MOV      r1,r0
;;;923    {
;;;924      uint8_t errorcode=0;
000724  2000              MOVS     r0,#0
;;;925      
;;;926      /* Check the parameters */
;;;927      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;928      
;;;929      /* Get the error code*/
;;;930      errorcode = (((uint8_t)CANx->ESR) & (uint8_t)CAN_ESR_LEC);
000726  698a              LDR      r2,[r1,#0x18]
000728  f0020070          AND      r0,r2,#0x70
;;;931      
;;;932      /* Return the error code*/
;;;933      return errorcode;
;;;934    }
00072c  4770              BX       lr
;;;935    /**
                          ENDP

                  CAN_GetReceiveErrorCounter PROC
;;;945      */
;;;946    uint8_t CAN_GetReceiveErrorCounter(CAN_TypeDef* CANx)
00072e  4601              MOV      r1,r0
;;;947    {
;;;948      uint8_t counter=0;
000730  2000              MOVS     r0,#0
;;;949      
;;;950      /* Check the parameters */
;;;951      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;952      
;;;953      /* Get the Receive Error Counter*/
;;;954      counter = (uint8_t)((CANx->ESR & CAN_ESR_REC)>> 24);
000732  698a              LDR      r2,[r1,#0x18]
000734  0e10              LSRS     r0,r2,#24
;;;955      
;;;956      /* Return the Receive Error Counter*/
;;;957      return counter;
;;;958    }
000736  4770              BX       lr
;;;959    
                          ENDP

                  CAN_GetLSBTransmitErrorCounter PROC
;;;965      */
;;;966    uint8_t CAN_GetLSBTransmitErrorCounter(CAN_TypeDef* CANx)
000738  4601              MOV      r1,r0
;;;967    {
;;;968      uint8_t counter=0;
00073a  2000              MOVS     r0,#0
;;;969      
;;;970      /* Check the parameters */
;;;971      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;972      
;;;973      /* Get the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
;;;974      counter = (uint8_t)((CANx->ESR & CAN_ESR_TEC)>> 16);
00073c  698a              LDR      r2,[r1,#0x18]
00073e  f3c24007          UBFX     r0,r2,#16,#8
;;;975      
;;;976      /* Return the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
;;;977      return counter;
;;;978    }
000742  4770              BX       lr
;;;979    
                          ENDP

                  CAN_ITConfig PROC
;;;1002     */
;;;1003   void CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState)
000744  b11a              CBZ      r2,|L1.1870|
;;;1004   {
;;;1005     /* Check the parameters */
;;;1006     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1007     assert_param(IS_CAN_IT(CAN_IT));
;;;1008     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1009   
;;;1010     if (NewState != DISABLE)
;;;1011     {
;;;1012       /* Enable the selected CANx interrupt */
;;;1013       CANx->IER |= CAN_IT;
000746  6943              LDR      r3,[r0,#0x14]
000748  430b              ORRS     r3,r3,r1
00074a  6143              STR      r3,[r0,#0x14]
00074c  e002              B        |L1.1876|
                  |L1.1870|
;;;1014     }
;;;1015     else
;;;1016     {
;;;1017       /* Disable the selected CANx interrupt */
;;;1018       CANx->IER &= ~CAN_IT;
00074e  6943              LDR      r3,[r0,#0x14]
000750  438b              BICS     r3,r3,r1
000752  6143              STR      r3,[r0,#0x14]
                  |L1.1876|
;;;1019     }
;;;1020   }
000754  4770              BX       lr
;;;1021   /**
                          ENDP

                  CAN_GetFlagStatus PROC
;;;1042     */
;;;1043   FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
000756  b510              PUSH     {r4,lr}
;;;1044   {
000758  4602              MOV      r2,r0
;;;1045     FlagStatus bitstatus = RESET;
00075a  2000              MOVS     r0,#0
;;;1046     
;;;1047     /* Check the parameters */
;;;1048     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1049     assert_param(IS_CAN_GET_FLAG(CAN_FLAG));
;;;1050     
;;;1051   
;;;1052     if((CAN_FLAG & CAN_FLAGS_ESR) != (uint32_t)RESET)
00075c  f4110f70          TST      r1,#0xf00000
000760  d008              BEQ      |L1.1908|
;;;1053     { 
;;;1054       /* Check the status of the specified CAN flag */
;;;1055       if ((CANx->ESR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
000762  6993              LDR      r3,[r2,#0x18]
000764  f3c10413          UBFX     r4,r1,#0,#20
000768  4223              TST      r3,r4
00076a  d001              BEQ      |L1.1904|
;;;1056       { 
;;;1057         /* CAN_FLAG is set */
;;;1058         bitstatus = SET;
00076c  2001              MOVS     r0,#1
00076e  e02d              B        |L1.1996|
                  |L1.1904|
;;;1059       }
;;;1060       else
;;;1061       { 
;;;1062         /* CAN_FLAG is reset */
;;;1063         bitstatus = RESET;
000770  2000              MOVS     r0,#0
000772  e02b              B        |L1.1996|
                  |L1.1908|
;;;1064       }
;;;1065     }
;;;1066     else if((CAN_FLAG & CAN_FLAGS_MSR) != (uint32_t)RESET)
000774  f0117f80          TST      r1,#0x1000000
000778  d008              BEQ      |L1.1932|
;;;1067     { 
;;;1068       /* Check the status of the specified CAN flag */
;;;1069       if ((CANx->MSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
00077a  6853              LDR      r3,[r2,#4]
00077c  f3c10413          UBFX     r4,r1,#0,#20
000780  4223              TST      r3,r4
000782  d001              BEQ      |L1.1928|
;;;1070       { 
;;;1071         /* CAN_FLAG is set */
;;;1072         bitstatus = SET;
000784  2001              MOVS     r0,#1
000786  e021              B        |L1.1996|
                  |L1.1928|
;;;1073       }
;;;1074       else
;;;1075       { 
;;;1076         /* CAN_FLAG is reset */
;;;1077         bitstatus = RESET;
000788  2000              MOVS     r0,#0
00078a  e01f              B        |L1.1996|
                  |L1.1932|
;;;1078       }
;;;1079     }
;;;1080     else if((CAN_FLAG & CAN_FLAGS_TSR) != (uint32_t)RESET)
00078c  f0116f00          TST      r1,#0x8000000
000790  d008              BEQ      |L1.1956|
;;;1081     { 
;;;1082       /* Check the status of the specified CAN flag */
;;;1083       if ((CANx->TSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
000792  6893              LDR      r3,[r2,#8]
000794  f3c10413          UBFX     r4,r1,#0,#20
000798  4223              TST      r3,r4
00079a  d001              BEQ      |L1.1952|
;;;1084       { 
;;;1085         /* CAN_FLAG is set */
;;;1086         bitstatus = SET;
00079c  2001              MOVS     r0,#1
00079e  e015              B        |L1.1996|
                  |L1.1952|
;;;1087       }
;;;1088       else
;;;1089       { 
;;;1090         /* CAN_FLAG is reset */
;;;1091         bitstatus = RESET;
0007a0  2000              MOVS     r0,#0
0007a2  e013              B        |L1.1996|
                  |L1.1956|
;;;1092       }
;;;1093     }
;;;1094     else if((CAN_FLAG & CAN_FLAGS_RF0R) != (uint32_t)RESET)
0007a4  f0117f00          TST      r1,#0x2000000
0007a8  d008              BEQ      |L1.1980|
;;;1095     { 
;;;1096       /* Check the status of the specified CAN flag */
;;;1097       if ((CANx->RF0R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
0007aa  68d3              LDR      r3,[r2,#0xc]
0007ac  f3c10413          UBFX     r4,r1,#0,#20
0007b0  4223              TST      r3,r4
0007b2  d001              BEQ      |L1.1976|
;;;1098       { 
;;;1099         /* CAN_FLAG is set */
;;;1100         bitstatus = SET;
0007b4  2001              MOVS     r0,#1
0007b6  e009              B        |L1.1996|
                  |L1.1976|
;;;1101       }
;;;1102       else
;;;1103       { 
;;;1104         /* CAN_FLAG is reset */
;;;1105         bitstatus = RESET;
0007b8  2000              MOVS     r0,#0
0007ba  e007              B        |L1.1996|
                  |L1.1980|
;;;1106       }
;;;1107     }
;;;1108     else /* If(CAN_FLAG & CAN_FLAGS_RF1R != (uint32_t)RESET) */
;;;1109     { 
;;;1110       /* Check the status of the specified CAN flag */
;;;1111       if ((uint32_t)(CANx->RF1R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
0007bc  6913              LDR      r3,[r2,#0x10]
0007be  f3c10413          UBFX     r4,r1,#0,#20
0007c2  4223              TST      r3,r4
0007c4  d001              BEQ      |L1.1994|
;;;1112       { 
;;;1113         /* CAN_FLAG is set */
;;;1114         bitstatus = SET;
0007c6  2001              MOVS     r0,#1
0007c8  e000              B        |L1.1996|
                  |L1.1994|
;;;1115       }
;;;1116       else
;;;1117       { 
;;;1118         /* CAN_FLAG is reset */
;;;1119         bitstatus = RESET;
0007ca  2000              MOVS     r0,#0
                  |L1.1996|
;;;1120       }
;;;1121     }
;;;1122     /* Return the CAN_FLAG status */
;;;1123     return  bitstatus;
;;;1124   }
0007cc  bd10              POP      {r4,pc}
;;;1125   
                          ENDP

                  CAN_ClearFlag PROC
;;;1142     */
;;;1143   void CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
0007ce  2200              MOVS     r2,#0
;;;1144   {
;;;1145     uint32_t flagtmp=0;
;;;1146     /* Check the parameters */
;;;1147     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1148     assert_param(IS_CAN_CLEAR_FLAG(CAN_FLAG));
;;;1149     
;;;1150     if (CAN_FLAG == CAN_FLAG_LEC) /* ESR register */
0007d0  4b23              LDR      r3,|L1.2144|
0007d2  4299              CMP      r1,r3
0007d4  d102              BNE      |L1.2012|
;;;1151     {
;;;1152       /* Clear the selected CAN flags */
;;;1153       CANx->ESR = (uint32_t)RESET;
0007d6  2300              MOVS     r3,#0
0007d8  6183              STR      r3,[r0,#0x18]
0007da  e011              B        |L1.2048|
                  |L1.2012|
;;;1154     }
;;;1155     else /* MSR or TSR or RF0R or RF1R */
;;;1156     {
;;;1157       flagtmp = CAN_FLAG & 0x000FFFFF;
0007dc  f3c10213          UBFX     r2,r1,#0,#20
;;;1158   
;;;1159       if ((CAN_FLAG & CAN_FLAGS_RF0R)!=(uint32_t)RESET)
0007e0  f0117f00          TST      r1,#0x2000000
0007e4  d001              BEQ      |L1.2026|
;;;1160       {
;;;1161         /* Receive Flags */
;;;1162         CANx->RF0R = (uint32_t)(flagtmp);
0007e6  60c2              STR      r2,[r0,#0xc]
0007e8  e00a              B        |L1.2048|
                  |L1.2026|
;;;1163       }
;;;1164       else if ((CAN_FLAG & CAN_FLAGS_RF1R)!=(uint32_t)RESET)
0007ea  f0116f80          TST      r1,#0x4000000
0007ee  d001              BEQ      |L1.2036|
;;;1165       {
;;;1166         /* Receive Flags */
;;;1167         CANx->RF1R = (uint32_t)(flagtmp);
0007f0  6102              STR      r2,[r0,#0x10]
0007f2  e005              B        |L1.2048|
                  |L1.2036|
;;;1168       }
;;;1169       else if ((CAN_FLAG & CAN_FLAGS_TSR)!=(uint32_t)RESET)
0007f4  f0116f00          TST      r1,#0x8000000
0007f8  d001              BEQ      |L1.2046|
;;;1170       {
;;;1171         /* Transmit Flags */
;;;1172         CANx->TSR = (uint32_t)(flagtmp);
0007fa  6082              STR      r2,[r0,#8]
0007fc  e000              B        |L1.2048|
                  |L1.2046|
;;;1173       }
;;;1174       else /* If((CAN_FLAG & CAN_FLAGS_MSR)!=(uint32_t)RESET) */
;;;1175       {
;;;1176         /* Operating mode Flags */
;;;1177         CANx->MSR = (uint32_t)(flagtmp);
0007fe  6042              STR      r2,[r0,#4]
                  |L1.2048|
;;;1178       }
;;;1179     }
;;;1180   }
000800  4770              BX       lr
;;;1181   
                          ENDP

                  CheckITStatus PROC
;;;1384     */
;;;1385   static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit)
000802  4602              MOV      r2,r0
;;;1386   {
;;;1387     ITStatus pendingbitstatus = RESET;
000804  2000              MOVS     r0,#0
;;;1388     
;;;1389     if ((CAN_Reg & It_Bit) != (uint32_t)RESET)
000806  420a              TST      r2,r1
000808  d001              BEQ      |L1.2062|
;;;1390     {
;;;1391       /* CAN_IT is set */
;;;1392       pendingbitstatus = SET;
00080a  2001              MOVS     r0,#1
00080c  e000              B        |L1.2064|
                  |L1.2062|
;;;1393     }
;;;1394     else
;;;1395     {
;;;1396       /* CAN_IT is reset */
;;;1397       pendingbitstatus = RESET;
00080e  2000              MOVS     r0,#0
                  |L1.2064|
;;;1398     }
;;;1399     return pendingbitstatus;
;;;1400   }
000810  4770              BX       lr
;;;1401   
                          ENDP

                  CAN_GetITStatus PROC
;;;1202     */
;;;1203   ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT)
000812  b570              PUSH     {r4-r6,lr}
;;;1204   {
000814  4604              MOV      r4,r0
000816  460d              MOV      r5,r1
;;;1205     ITStatus itstatus = RESET;
000818  2600              MOVS     r6,#0
;;;1206     /* Check the parameters */
;;;1207     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1208     assert_param(IS_CAN_IT(CAN_IT));
;;;1209     
;;;1210     /* check the enable interrupt bit */
;;;1211    if((CANx->IER & CAN_IT) != RESET)
00081a  6960              LDR      r0,[r4,#0x14]
00081c  4228              TST      r0,r5
00081e  d072              BEQ      |L1.2310|
;;;1212    {
;;;1213      /* in case the Interrupt is enabled, .... */
;;;1214       switch (CAN_IT)
000820  f5b57f80          CMP      r5,#0x100
000824  d069              BEQ      |L1.2298|
000826  dc1d              BGT      |L1.2148|
000828  2d08              CMP      r5,#8
00082a  d042              BEQ      |L1.2226|
00082c  dc06              BGT      |L1.2108|
00082e  2d01              CMP      r5,#1
000830  d02d              BEQ      |L1.2190|
000832  2d02              CMP      r5,#2
000834  d031              BEQ      |L1.2202|
000836  2d04              CMP      r5,#4
000838  d17f              BNE      |L1.2362|
00083a  e034              B        |L1.2214|
                  |L1.2108|
00083c  2d10              CMP      r5,#0x10
00083e  d03e              BEQ      |L1.2238|
000840  2d20              CMP      r5,#0x20
000842  d042              BEQ      |L1.2250|
000844  2d40              CMP      r5,#0x40
000846  d178              BNE      |L1.2362|
000848  e045              B        |L1.2262|
00084a  0000              DCW      0x0000
                  |L1.2124|
                          DCD      0x04000003
                  |L1.2128|
                          DCD      0x08000300
                  |L1.2132|
                          DCD      0x10030000
                  |L1.2136|
                          DCD      0x08000100
                  |L1.2140|
                          DCD      0xf7ff0100
                  |L1.2144|
                          DCD      0x30f00070
                  |L1.2148|
000864  f5b54f00          CMP      r5,#0x8000
000868  d061              BEQ      |L1.2350|
00086a  dc09              BGT      |L1.2176|
00086c  f5b57f00          CMP      r5,#0x200
000870  d04a              BEQ      |L1.2312|
000872  f5b56f80          CMP      r5,#0x400
000876  d04d              BEQ      |L1.2324|
000878  f5b56f00          CMP      r5,#0x800
00087c  d15d              BNE      |L1.2362|
00087e  e050              B        |L1.2338|
                  |L1.2176|
000880  f5b53f80          CMP      r5,#0x10000
000884  d02d              BEQ      |L1.2274|
000886  f5b53f00          CMP      r5,#0x20000
00088a  d156              BNE      |L1.2362|
00088c  e02f              B        |L1.2286|
                  |L1.2190|
;;;1215       {
;;;1216         case CAN_IT_TME:
;;;1217                  /* Check CAN_TSR_RQCPx bits */
;;;1218   	             itstatus = CheckITStatus(CANx->TSR, CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2);  
00088e  68a0              LDR      r0,[r4,#8]
000890  4955              LDR      r1,|L1.2536|
000892  f7fffffe          BL       CheckITStatus
000896  4606              MOV      r6,r0
;;;1219   	      break;
000898  e051              B        |L1.2366|
                  |L1.2202|
;;;1220         case CAN_IT_FMP0:
;;;1221                  /* Check CAN_RF0R_FMP0 bit */
;;;1222   	             itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FMP0);  
00089a  68e0              LDR      r0,[r4,#0xc]
00089c  2103              MOVS     r1,#3
00089e  f7fffffe          BL       CheckITStatus
0008a2  4606              MOV      r6,r0
;;;1223   	      break;
0008a4  e04b              B        |L1.2366|
                  |L1.2214|
;;;1224         case CAN_IT_FF0:
;;;1225                  /* Check CAN_RF0R_FULL0 bit */
;;;1226                  itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FULL0);  
0008a6  68e0              LDR      r0,[r4,#0xc]
0008a8  2108              MOVS     r1,#8
0008aa  f7fffffe          BL       CheckITStatus
0008ae  4606              MOV      r6,r0
;;;1227   	      break;
0008b0  e045              B        |L1.2366|
                  |L1.2226|
;;;1228         case CAN_IT_FOV0:
;;;1229                  /* Check CAN_RF0R_FOVR0 bit */
;;;1230                  itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FOVR0);  
0008b2  68e0              LDR      r0,[r4,#0xc]
0008b4  2110              MOVS     r1,#0x10
0008b6  f7fffffe          BL       CheckITStatus
0008ba  4606              MOV      r6,r0
;;;1231   	      break;
0008bc  e03f              B        |L1.2366|
                  |L1.2238|
;;;1232         case CAN_IT_FMP1:
;;;1233                  /* Check CAN_RF1R_FMP1 bit */
;;;1234                  itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FMP1);  
0008be  6920              LDR      r0,[r4,#0x10]
0008c0  2103              MOVS     r1,#3
0008c2  f7fffffe          BL       CheckITStatus
0008c6  4606              MOV      r6,r0
;;;1235   	      break;
0008c8  e039              B        |L1.2366|
                  |L1.2250|
;;;1236         case CAN_IT_FF1:
;;;1237                  /* Check CAN_RF1R_FULL1 bit */
;;;1238   	             itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FULL1);  
0008ca  6920              LDR      r0,[r4,#0x10]
0008cc  2108              MOVS     r1,#8
0008ce  f7fffffe          BL       CheckITStatus
0008d2  4606              MOV      r6,r0
;;;1239   	      break;
0008d4  e033              B        |L1.2366|
                  |L1.2262|
;;;1240         case CAN_IT_FOV1:
;;;1241                  /* Check CAN_RF1R_FOVR1 bit */
;;;1242   	             itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FOVR1);  
0008d6  6920              LDR      r0,[r4,#0x10]
0008d8  2110              MOVS     r1,#0x10
0008da  f7fffffe          BL       CheckITStatus
0008de  4606              MOV      r6,r0
;;;1243   	      break;
0008e0  e02d              B        |L1.2366|
                  |L1.2274|
;;;1244         case CAN_IT_WKU:
;;;1245                  /* Check CAN_MSR_WKUI bit */
;;;1246                  itstatus = CheckITStatus(CANx->MSR, CAN_MSR_WKUI);  
0008e2  6860              LDR      r0,[r4,#4]
0008e4  2108              MOVS     r1,#8
0008e6  f7fffffe          BL       CheckITStatus
0008ea  4606              MOV      r6,r0
;;;1247   	      break;
0008ec  e027              B        |L1.2366|
                  |L1.2286|
;;;1248         case CAN_IT_SLK:
;;;1249                  /* Check CAN_MSR_SLAKI bit */
;;;1250   	             itstatus = CheckITStatus(CANx->MSR, CAN_MSR_SLAKI);  
0008ee  6860              LDR      r0,[r4,#4]
0008f0  2110              MOVS     r1,#0x10
0008f2  f7fffffe          BL       CheckITStatus
0008f6  4606              MOV      r6,r0
;;;1251   	      break;
0008f8  e021              B        |L1.2366|
                  |L1.2298|
;;;1252         case CAN_IT_EWG:
;;;1253                  /* Check CAN_ESR_EWGF bit */
;;;1254   	             itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EWGF);  
0008fa  69a0              LDR      r0,[r4,#0x18]
0008fc  2101              MOVS     r1,#1
0008fe  f7fffffe          BL       CheckITStatus
000902  4606              MOV      r6,r0
;;;1255   	      break;
000904  e01b              B        |L1.2366|
                  |L1.2310|
000906  e01b              B        |L1.2368|
                  |L1.2312|
;;;1256         case CAN_IT_EPV:
;;;1257                  /* Check CAN_ESR_EPVF bit */
;;;1258   	             itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EPVF);  
000908  69a0              LDR      r0,[r4,#0x18]
00090a  2102              MOVS     r1,#2
00090c  f7fffffe          BL       CheckITStatus
000910  4606              MOV      r6,r0
;;;1259   	      break;
000912  e014              B        |L1.2366|
                  |L1.2324|
;;;1260         case CAN_IT_BOF:
;;;1261                  /* Check CAN_ESR_BOFF bit */
;;;1262   	             itstatus = CheckITStatus(CANx->ESR, CAN_ESR_BOFF);  
000914  69a0              LDR      r0,[r4,#0x18]
000916  2104              MOVS     r1,#4
000918  f7fffffe          BL       CheckITStatus
00091c  4606              MOV      r6,r0
;;;1263   	      break;
00091e  e00e              B        |L1.2366|
000920  e00b              B        |L1.2362|
                  |L1.2338|
;;;1264         case CAN_IT_LEC:
;;;1265                  /* Check CAN_ESR_LEC bit */
;;;1266   	             itstatus = CheckITStatus(CANx->ESR, CAN_ESR_LEC);  
000922  69a0              LDR      r0,[r4,#0x18]
000924  2170              MOVS     r1,#0x70
000926  f7fffffe          BL       CheckITStatus
00092a  4606              MOV      r6,r0
;;;1267   	      break;
00092c  e007              B        |L1.2366|
                  |L1.2350|
;;;1268         case CAN_IT_ERR:
;;;1269                  /* Check CAN_MSR_ERRI bit */ 
;;;1270                  itstatus = CheckITStatus(CANx->MSR, CAN_MSR_ERRI); 
00092e  6860              LDR      r0,[r4,#4]
000930  2104              MOVS     r1,#4
000932  f7fffffe          BL       CheckITStatus
000936  4606              MOV      r6,r0
;;;1271   	      break;
000938  e001              B        |L1.2366|
                  |L1.2362|
;;;1272         default :
;;;1273                  /* in case of error, return RESET */
;;;1274                 itstatus = RESET;
00093a  2600              MOVS     r6,#0
;;;1275                 break;
00093c  bf00              NOP      
                  |L1.2366|
00093e  e000              B        |L1.2370|
                  |L1.2368|
;;;1276       }
;;;1277     }
;;;1278     else
;;;1279     {
;;;1280      /* in case the Interrupt is not enabled, return RESET */
;;;1281       itstatus  = RESET;
000940  2600              MOVS     r6,#0
                  |L1.2370|
;;;1282     }
;;;1283     
;;;1284     /* Return the CAN_IT status */
;;;1285     return  itstatus;
000942  4630              MOV      r0,r6
;;;1286   }
000944  bd70              POP      {r4-r6,pc}
;;;1287   
                          ENDP

                  CAN_ClearITPendingBit PROC
;;;1305     */
;;;1306   void CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT)
000946  f5b17f00          CMP      r1,#0x200
;;;1307   {
;;;1308     /* Check the parameters */
;;;1309     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1310     assert_param(IS_CAN_CLEAR_IT(CAN_IT));
;;;1311   
;;;1312     switch (CAN_IT)
00094a  d03a              BEQ      |L1.2498|
00094c  dc0f              BGT      |L1.2414|
00094e  2920              CMP      r1,#0x20
000950  d028              BEQ      |L1.2468|
000952  dc06              BGT      |L1.2402|
000954  2901              CMP      r1,#1
000956  d01c              BEQ      |L1.2450|
000958  2904              CMP      r1,#4
00095a  d01d              BEQ      |L1.2456|
00095c  2908              CMP      r1,#8
00095e  d140              BNE      |L1.2530|
000960  e01d              B        |L1.2462|
                  |L1.2402|
000962  2940              CMP      r1,#0x40
000964  d021              BEQ      |L1.2474|
000966  f5b17f80          CMP      r1,#0x100
00096a  d13a              BNE      |L1.2530|
00096c  e026              B        |L1.2492|
                  |L1.2414|
00096e  f5b14f00          CMP      r1,#0x8000
000972  d031              BEQ      |L1.2520|
000974  dc06              BGT      |L1.2436|
000976  f5b16f80          CMP      r1,#0x400
00097a  d025              BEQ      |L1.2504|
00097c  f5b16f00          CMP      r1,#0x800
000980  d12f              BNE      |L1.2530|
000982  e024              B        |L1.2510|
                  |L1.2436|
000984  f5b13f80          CMP      r1,#0x10000
000988  d012              BEQ      |L1.2480|
00098a  f5b13f00          CMP      r1,#0x20000
00098e  d128              BNE      |L1.2530|
000990  e011              B        |L1.2486|
                  |L1.2450|
;;;1313     {
;;;1314         case CAN_IT_TME:
;;;1315                 /* Clear CAN_TSR_RQCPx (rc_w1)*/
;;;1316   	      CANx->TSR = CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2;  
000992  4a15              LDR      r2,|L1.2536|
000994  6082              STR      r2,[r0,#8]
;;;1317   	      break;
000996  e025              B        |L1.2532|
                  |L1.2456|
;;;1318         case CAN_IT_FF0:
;;;1319                 /* Clear CAN_RF0R_FULL0 (rc_w1)*/
;;;1320   	      CANx->RF0R = CAN_RF0R_FULL0; 
000998  2208              MOVS     r2,#8
00099a  60c2              STR      r2,[r0,#0xc]
;;;1321   	      break;
00099c  e022              B        |L1.2532|
                  |L1.2462|
;;;1322         case CAN_IT_FOV0:
;;;1323                 /* Clear CAN_RF0R_FOVR0 (rc_w1)*/
;;;1324   	      CANx->RF0R = CAN_RF0R_FOVR0; 
00099e  2210              MOVS     r2,#0x10
0009a0  60c2              STR      r2,[r0,#0xc]
;;;1325   	      break;
0009a2  e01f              B        |L1.2532|
                  |L1.2468|
;;;1326         case CAN_IT_FF1:
;;;1327                 /* Clear CAN_RF1R_FULL1 (rc_w1)*/
;;;1328   	      CANx->RF1R = CAN_RF1R_FULL1;  
0009a4  2208              MOVS     r2,#8
0009a6  6102              STR      r2,[r0,#0x10]
;;;1329   	      break;
0009a8  e01c              B        |L1.2532|
                  |L1.2474|
;;;1330         case CAN_IT_FOV1:
;;;1331                 /* Clear CAN_RF1R_FOVR1 (rc_w1)*/
;;;1332   	      CANx->RF1R = CAN_RF1R_FOVR1; 
0009aa  2210              MOVS     r2,#0x10
0009ac  6102              STR      r2,[r0,#0x10]
;;;1333   	      break;
0009ae  e019              B        |L1.2532|
                  |L1.2480|
;;;1334         case CAN_IT_WKU:
;;;1335                 /* Clear CAN_MSR_WKUI (rc_w1)*/
;;;1336   	      CANx->MSR = CAN_MSR_WKUI;  
0009b0  2208              MOVS     r2,#8
0009b2  6042              STR      r2,[r0,#4]
;;;1337   	      break;
0009b4  e016              B        |L1.2532|
                  |L1.2486|
;;;1338         case CAN_IT_SLK:
;;;1339                 /* Clear CAN_MSR_SLAKI (rc_w1)*/ 
;;;1340   	      CANx->MSR = CAN_MSR_SLAKI;   
0009b6  2210              MOVS     r2,#0x10
0009b8  6042              STR      r2,[r0,#4]
;;;1341   	      break;
0009ba  e013              B        |L1.2532|
                  |L1.2492|
;;;1342         case CAN_IT_EWG:
;;;1343                 /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1344   	      CANx->MSR = CAN_MSR_ERRI;
0009bc  2204              MOVS     r2,#4
0009be  6042              STR      r2,[r0,#4]
;;;1345                 /* Note : the corresponding Flag is cleared by hardware depending 
;;;1346                           of the CAN Bus status*/ 
;;;1347   	      break;
0009c0  e010              B        |L1.2532|
                  |L1.2498|
;;;1348         case CAN_IT_EPV:
;;;1349                 /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1350   	      CANx->MSR = CAN_MSR_ERRI; 
0009c2  2204              MOVS     r2,#4
0009c4  6042              STR      r2,[r0,#4]
;;;1351                 /* Note : the corresponding Flag is cleared by hardware depending 
;;;1352                           of the CAN Bus status*/
;;;1353   	      break;
0009c6  e00d              B        |L1.2532|
                  |L1.2504|
;;;1354         case CAN_IT_BOF:
;;;1355                 /* Clear CAN_MSR_ERRI (rc_w1) */ 
;;;1356   	      CANx->MSR = CAN_MSR_ERRI; 
0009c8  2204              MOVS     r2,#4
0009ca  6042              STR      r2,[r0,#4]
;;;1357                 /* Note : the corresponding Flag is cleared by hardware depending 
;;;1358                           of the CAN Bus status*/
;;;1359   	      break;
0009cc  e00a              B        |L1.2532|
                  |L1.2510|
;;;1360         case CAN_IT_LEC:
;;;1361                 /*  Clear LEC bits */
;;;1362   	      CANx->ESR = RESET; 
0009ce  2200              MOVS     r2,#0
0009d0  6182              STR      r2,[r0,#0x18]
;;;1363                 /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1364   	      CANx->MSR = CAN_MSR_ERRI; 
0009d2  2204              MOVS     r2,#4
0009d4  6042              STR      r2,[r0,#4]
;;;1365   	      break;
0009d6  e005              B        |L1.2532|
                  |L1.2520|
;;;1366         case CAN_IT_ERR:
;;;1367                 /*Clear LEC bits */
;;;1368   	      CANx->ESR = RESET; 
0009d8  2200              MOVS     r2,#0
0009da  6182              STR      r2,[r0,#0x18]
;;;1369                 /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1370   	      CANx->MSR = CAN_MSR_ERRI; 
0009dc  2204              MOVS     r2,#4
0009de  6042              STR      r2,[r0,#4]
;;;1371   	      /* Note : BOFF, EPVF and EWGF Flags are cleared by hardware depending 
;;;1372                     of the CAN Bus status*/
;;;1373   	      break;
0009e0  e000              B        |L1.2532|
                  |L1.2530|
;;;1374         default :
;;;1375   	      break;
0009e2  bf00              NOP      
                  |L1.2532|
0009e4  bf00              NOP                            ;1317
;;;1376      }
;;;1377   }
0009e6  4770              BX       lr
;;;1378   
                          ENDP

                  |L1.2536|
                          DCD      0x00010101

;*** Start embedded assembler ***

#line 1 "..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_can.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f10x_can_c_347dae01____REV16|
#line 129 "E:\\keli\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f10x_can_c_347dae01____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f10x_can_c_347dae01____REVSH|
#line 144
|__asm___15_stm32f10x_can_c_347dae01____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
